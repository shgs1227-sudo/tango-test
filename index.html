<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>üìö Vocabulary Test - Mobile</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        /* Mobile-First Custom Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        :root {
            /* Dark Theme Colors */
            --bg-gradient-start: #1e3a8a;
            --bg-gradient-end: #1e293b;
            --glass-bg: rgba(30, 58, 138, 0.7);
            --glass-border: rgba(100, 150, 255, 0.15);
            --glass-shadow: rgba(0, 0, 0, 0.4);
            --text-primary: #ffffff;
            --text-secondary: #e0f2fe;
            --text-muted: #cbd5e1;
            --input-bg: rgba(30, 41, 59, 0.8);
            --input-border: rgba(6, 182, 212, 0.4);
            --input-focus-bg: rgba(30, 41, 59, 0.95);
            --input-text: #ffffff;
            --card-bg: rgba(59, 130, 246, 0.15);
            --card-hover: rgba(59, 130, 246, 0.25);
            --safe-area-top: env(safe-area-inset-top);
            --safe-area-bottom: env(safe-area-inset-bottom);
        }
        
        [data-theme="light"] {
            /* Light Theme Colors */
            --bg-gradient-start: #dbeafe;
            --bg-gradient-end: #f0f9ff;
            --glass-bg: rgba(255, 255, 255, 0.85);
            --glass-border: rgba(59, 130, 246, 0.25);
            --glass-shadow: rgba(0, 0, 0, 0.15);
            --text-primary: #1e293b;
            --text-secondary: #334155;
            --text-muted: #64748b;
            --input-bg: rgba(255, 255, 255, 0.95);
            --input-border: rgba(59, 130, 246, 0.4);
            --input-focus-bg: rgba(255, 255, 255, 1);
            --input-text: #1e293b;
            --card-bg: rgba(59, 130, 246, 0.1);
            --card-hover: rgba(59, 130, 246, 0.18);
        }
        
        html {
            touch-action: manipulation;
            -webkit-text-size-adjust: 100%;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            position: relative;
            overflow-x: hidden;
            transition: background 0.3s ease;
            overscroll-behavior-y: contain;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(59, 130, 246, 0.2), transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(14, 165, 233, 0.2), transparent 50%);
            pointer-events: none;
            z-index: 0;
        }
        
        .app-container {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            display: flex;
            flex-direction: column;
            padding-top: var(--safe-area-top);
            padding-bottom: var(--safe-area-bottom);
        }
        
        /* Theme Toggle - Mobile Optimized */
        .theme-toggle {
            position: fixed;
            top: calc(16px + var(--safe-area-top));
            right: 16px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 50%;
            width: 52px;
            height: 52px;
            border: 2px solid var(--glass-border);
            box-shadow: 0 6px 20px var(--glass-shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 9999;
            font-size: 24px;
            user-select: none;
        }
        
        .theme-toggle:active {
            transform: scale(0.92);
        }
        
        /* Glass Card - Mobile Optimized */
        .glass-card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 
                0 10px 35px 0 var(--glass-shadow),
                inset 0 0 0 1px var(--glass-border);
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease;
        }
        
        /* Compact Previous Answer Card */
        .previous-answer-card {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 0.6rem 0.9rem;
            margin-bottom: 0.75rem;
            box-shadow: 0 4px 15px var(--glass-shadow);
            animation: slideDown 0.4s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }
        .previous-answer-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-weight: 600;
            margin-bottom: 0;
            display: block;
            white-space: nowrap;
        }
        .previous-answer-content {
            display: flex;
            align-items: baseline;
            justify-content: flex-end;
            gap: 0.5rem;
            text-align: right;
            flex-wrap: wrap;
        }
        .previous-answer-main {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .previous-answer-sub {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-secondary);
        }
        
        /* Word Card - Mobile Optimized with Swipe */
        .word-card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: 0 12px 40px 0 var(--glass-shadow);
            overflow: hidden;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            touch-action: pan-y;
            user-select: none;
        }
        
        .word-card.swiping {
            transition: none;
        }
        
        /* Question Display - Optimized Size */
        .question-display {
            min-height: 160px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem 1.2rem;
            background: var(--card-bg);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .question-text {
            font-size: 1.8rem;
            font-weight: 900;
            color: var(--text-primary);
            text-align: center;
            line-height: 1.3;
            word-wrap: break-word;
            max-width: 100%;
        }
        
        .tap-hint {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 1rem;
            text-align: center;
            opacity: 0.7;
        }
        
        /* Answer Display */
        .answer-content {
            padding: 1.5rem 1.2rem;
            text-align: center;
            animation: slideDown 0.4s ease;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .answer-reading {
            font-size: 1.3rem;
            color: var(--text-primary);
            margin-bottom: 1rem;
            font-weight: 700;
        }
        
        .answer-meaning {
            font-size: 1.6rem;
            color: var(--text-secondary);
            line-height: 1.6;
            font-weight: 500;
        }
        
        /* Report Buttons - Optimized Size */
        .report-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 14px 0;
        }
        
        .report-btn {
            position: relative;
            border: none;
            border-radius: 18px;
            font-size: 2.8rem;
            font-weight: 900;
            padding: 1.2rem 0;
            transition: transform 0.2s ease;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .report-btn:active {
            transform: scale(0.93);
        }
        
        .report-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.4);
            transform: translate(-50%, -50%);
            transition: width 0.5s, height 0.5s;
        }
        
        .report-btn:active::before {
            width: 300px;
            height: 300px;
        }
        
        .btn-incorrect {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }
        
        .btn-review {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
        }
        
        .btn-correct {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }
        
        /* Navigation - Inline (Not Fixed) */
        .bottom-nav {
            background: transparent;
            padding: 0;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 14px;
            margin-bottom: 14px;
        }
        
        .nav-btn {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            color: white;
            font-weight: 700;
            padding: 1rem;
            border-radius: 16px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.3);
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .nav-btn:active:not(:disabled) {
            transform: scale(0.95);
        }
        
        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        /* Action Buttons - Large and Touchable */
        .btn-primary {
            background: linear-gradient(135deg, #06b6d4 0%, #0ea5e9 100%);
            color: white;
            font-weight: 700;
            padding: 1.2rem 2rem;
            border-radius: 16px;
            transition: all 0.2s ease;
            box-shadow: 0 6px 24px rgba(6, 182, 212, 0.45);
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            width: 100%;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .btn-primary:active:not(:disabled) {
            transform: scale(0.96);
        }
        
        .btn-primary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            font-weight: 700;
            padding: 1.2rem 2rem;
            border-radius: 16px;
            transition: all 0.2s ease;
            box-shadow: 0 6px 24px rgba(16, 185, 129, 0.45);
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            width: 100%;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .btn-secondary:active:not(:disabled) {
            transform: scale(0.96);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            font-weight: 700;
            padding: 1.2rem 2rem;
            border-radius: 16px;
            transition: all 0.2s ease;
            box-shadow: 0 6px 24px rgba(239, 68, 68, 0.45);
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            width: 100%;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .btn-danger:active {
            transform: scale(0.96);
        }
        
        /* Edit Button - Floating */
        .edit-btn {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            font-weight: 700;
            padding: 0.9rem 1.8rem;
            border-radius: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.45);
            border: none;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 1rem;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .edit-btn:active {
            transform: scale(0.95);
        }
        
        /* Statistics Badges - Compact 4-column */
        .stat-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.55rem 0.7rem;
            border-radius: 12px;
            font-weight: 700;
            font-size: 0.95rem;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.25);
            transition: transform 0.2s ease;
            user-select: none;
            -webkit-user-select: none;
            min-width: 0;
        }
        
        .stat-badge:active {
            transform: scale(0.95);
        }
        
        .stat-badge-correct {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }
        
        .stat-badge-review {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
        }
        
        .stat-badge-incorrect {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }
        
        .stat-badge-unevaluated {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            color: white;
        }
        
        .stat-badge-icon {
            font-size: 1.3rem;
            margin-right: 0.4rem;
        }
        
        /* Progress Bar - Thicker */
        .progress-container {
            width: 100%;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 14px;
            overflow: hidden;
            height: 14px;
            position: relative;
        }
        
        [data-theme="light"] .progress-container {
            background: rgba(203, 213, 225, 0.6);
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #06b6d4 0%, #0ea5e9 100%);
            border-radius: 14px;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 18px rgba(6, 182, 212, 0.7);
        }
        
        .progress-bar-unevaluated {
            background: linear-gradient(90deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 0 18px rgba(245, 158, 11, 0.7);
        }
        
        /* Modal - Slide Up from Bottom */
        .modal {
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 9998;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            max-height: 85vh;
            overflow-y: auto;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 24px 24px 0 0;
            padding: 1.5rem 1.5rem calc(1.5rem + var(--safe-area-bottom));
            box-shadow: 0 -8px 40px var(--glass-shadow);
            animation: slideUpModal 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes slideUpModal {
            from {
                opacity: 0;
                transform: translateY(100%);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .modal-handle {
            width: 40px;
            height: 4px;
            background: var(--text-muted);
            border-radius: 2px;
            margin: 0 auto 1.5rem;
            opacity: 0.5;
        }
        
        /* Input Forms - Mobile Optimized */
        textarea, input[type="text"], input[type="number"] {
            background: var(--input-bg);
            border: 2px solid var(--input-border);
            border-radius: 16px;
            padding: 1.2rem;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
            color: var(--input-text);
            font-size: 16px; /* Prevents zoom on iOS */
            width: 100%;
        }
        
        input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
        }
        
        textarea::placeholder, input::placeholder {
            color: var(--text-muted);
        }
        
        textarea:focus, input:focus {
            outline: none;
            border-color: #06b6d4;
            background: var(--input-focus-bg);
            box-shadow: 0 0 0 4px rgba(6, 182, 212, 0.25);
        }
        
        /* Toggle Switch - Larger */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 68px;
            height: 38px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            transition: .4s;
            border-radius: 38px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 30px;
            width: 30px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background: linear-gradient(135deg, #06b6d4 0%, #0ea5e9 100%);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }
        
        /* Loading Animation */
        .loading-dot {
            animation: bounce 0.6s infinite alternate;
            background: linear-gradient(135deg, #06b6d4 0%, #0ea5e9 100%);
        }
        
        .loading-dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-14px); }
        }
        
        /* Title */
        .app-title {
            color: var(--text-primary);
            text-shadow: 0 0 24px rgba(56, 189, 248, 0.6);
            font-weight: 900;
            letter-spacing: 0.5px;
        }
        
        /* Swipe Indicator */
        .swipe-indicator {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            font-size: 3rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }
        
        .swipe-indicator.left {
            left: 20px;
        }
        
        .swipe-indicator.right {
            right: 20px;
        }
        
        .swipe-indicator.visible {
            opacity: 0.6;
        }
        
        /* Content Padding */
        .content-wrapper {
            padding-bottom: calc(16px + var(--safe-area-bottom));
        }
        
        /* Scrollbar - Hidden on Mobile */
        ::-webkit-scrollbar {
            width: 0;
            height: 0;
        }
        
        /* Text Color Adjustments */
        .text-light {
            color: var(--text-primary);
        }
        
        .text-muted {
            color: var(--text-muted);
        }
        
        label {
            color: var(--text-primary);
        }
        
        .text-secondary {
            color: var(--text-secondary);
        }
        
        /* View Transition */
        .view-transition {
            animation: viewFadeIn 0.5s ease;
        }
        
        @keyframes viewFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Settings Button */
        .settings-btn {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            color: white;
            font-weight: 700;
            padding: 1rem 2rem;
            border-radius: 16px;
            transition: all 0.2s ease;
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
            border: none;
            cursor: pointer;
            font-size: 1.05rem;
            width: 100%;
            margin-top: 1.5rem;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .settings-btn:active {
            transform: scale(0.96);
        }
        
        /* Settings Item Card */
        .settings-item-card {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 1rem 1.2rem;
            margin-bottom: 0.75rem;
            box-shadow: 0 4px 15px var(--glass-shadow);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .settings-item-label {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        /* Utility */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Theme Toggle Button -->
    <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Theme">
        üåô
    </button>

    <!-- Swipe Indicators -->
    <div id="swipe-left" class="swipe-indicator left">‚Üê</div>
    <div id="swipe-right" class="swipe-indicator right">‚Üí</div>

    <!-- Main Container -->
    <div class="app-container">
        <div class="px-4 py-5 content-wrapper">

            <h1 class="text-3xl font-black text-center mb-4 app-title">üìö Vocabulary Test</h1>
            
            <!-- Status Message -->
            <div id="status-message" class="text-center mb-4 font-semibold text-light">
                <!-- JavaScript will insert content here -->
            </div>

            <!-- Loading Indicator -->
            <div id="loading-indicator" class="hidden text-center py-12 view-transition">
                <div class="flex justify-center space-x-3 mb-4">
                    <div class="w-4 h-4 rounded-full loading-dot"></div>
                    <div class="w-4 h-4 rounded-full loading-dot"></div>
                    <div class="w-4 h-4 rounded-full loading-dot"></div>
                </div>
                <p class="font-medium text-light">Loading...</p>
            </div>

            <!-- Setup View -->
            <div id="setup-view" class="view-transition">
                <div class="glass-card p-6 mb-6">
                    <h2 class="text-xl font-bold text-light mb-3">üìù Register Words</h2>
                    <p class="text-sm text-muted mb-4">Format: "word_reading_meaning" or "word_meaning"</p>
                    <textarea id="word-input" class="w-full h-48 text-sm mb-4" placeholder="Example:&#10;Words_Meaning&#10;Words_HowToRead_Meaning&#10;„Çä„Çì„Åî_apple&#10;ÎÜÄÎã§_„Éé„É´„ÉÄ_„ÅÇ„Åù„Å∂"></textarea>
                    <button id="save-words-btn" class="btn-primary">
                        Add to Database
                    </button>
                </div>

                <div class="glass-card p-6">
                    <h2 class="text-xl font-bold text-light mb-3">üîÑ Resume Test</h2>
                    <p id="resume-info" class="text-sm text-muted mb-3">No saved data</p>
                    <button id="resume-test-btn" class="btn-secondary" disabled>
                        Resume (<span id="last-updated-time">--</span>)
                    </button>
                </div>
            </div>

            <!-- Test View -->
            <div id="test-view" class="hidden view-transition">
                
                <!-- Previous Answer Display -->
                <div id="previous-answer-display" class="previous-answer-card hidden">
                    <span class="previous-answer-label">üìù Answer</span>
                    <div class="previous-answer-content" id="previous-answer-content-area">
                        <!-- JS„Åå„Åì„Åì„ÇíÊõ∏„ÅçÊèõ„Åà„Çã -->
                    </div>
                </div>
                
                <!-- Word Display Card -->
                <div id="word-display" class="word-card mb-4">
                    <div id="question-display" class="question-display">
                        <div>
                            <div id="question-word" class="question-text">Tap to Start</div>
                            <div class="tap-hint">üëÜ Tap to reveal answer</div>
                        </div>
                    </div>
                    <div id="answer-section" class="hidden">
                        <div class="answer-content">
                            <div id="answer-reading" class="answer-reading">Reading</div>
                            <div id="answer-meaning" class="answer-meaning">Meaning</div>
                            <button id="edit-word-btn" class="edit-btn">‚úèÔ∏è Edit</button>
                        </div>
                    </div>
                </div>

                <!-- Report Buttons -->
                <div id="report-buttons" class="report-buttons">
                    <button data-result="incorrect" class="report-btn btn-incorrect">√ó</button>
                    <button data-result="review" class="report-btn btn-review">‚ñ≥</button>
                    <button data-result="correct" class="report-btn btn-correct">„Äá</button>
                </div>
                
                <!-- Navigation Buttons (Moved Below Report Buttons) -->
                <div id="bottom-nav" class="bottom-nav">
                    <button id="prev-word-btn" class="nav-btn">
                        ‚Üê Back
                    </button>
                    <button id="next-word-btn" class="nav-btn">
                        Next ‚Üí
                    </button>
                </div>
                
                <!-- Statistics -->
                <div id="stats-display" class="glass-card p-5 space-y-4">
                    <!-- Unevaluated Progress -->
                    <div id="unevaluated-progress-section">
                        <p class="text-sm font-semibold text-light mb-2">üìã New Words (<span id="unevaluated-progress-text">0 / 0</span>)</p>
                        <div class="progress-container">
                            <div id="unevaluated-progress-bar" class="progress-bar progress-bar-unevaluated" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <!-- Overall Progress (Review mode text removed) -->
                    <div>
                        <p class="text-sm font-semibold text-light mb-2">üìä Progress (<span id="overall-progress-text">0 / 0</span>)</p>
                        <div class="progress-container">
                            <div id="overall-progress-bar" class="progress-bar" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <!-- Category Stats -->
                    <div class="pt-4 border-t-2 border-opacity-20" style="border-color: var(--text-muted);">
                        <div class="grid grid-cols-4 gap-2">
                            <div class="stat-badge stat-badge-unevaluated">
                                <span class="stat-badge-icon">‚àí</span>
                                <span id="unevaluated-count">0</span>
                            </div>
                            <div class="stat-badge stat-badge-correct">
                                <span class="stat-badge-icon">„Äá</span>
                                <span id="correct-count">0</span>
                            </div>
                            <div class="stat-badge stat-badge-review">
                                <span class="stat-badge-icon">‚ñ≥</span>
                                <span id="review-count">0</span>
                            </div>
                            <div class="stat-badge stat-badge-incorrect">
                                <span class="stat-badge-icon">√ó</span>
                                <span id="incorrect-count">0</span>
                            </div>
                        </div>
                        <p class="text-sm text-light text-center mt-3">Total: <span id="total-words-count" class="font-bold">0</span></p>
                    </div>
                </div>

                <button id="open-settings-btn" class="settings-btn">
                    ‚öôÔ∏è Settings
                </button>
            </div>

        </div>
    </div>

    <!-- Message Modal -->
    <div id="custom-modal" class="modal fixed inset-0 flex items-end hidden">
        <div class="modal-content w-full">
            <div class="modal-handle"></div>
            <h3 id="modal-title" class="text-2xl font-bold mb-4 text-light">Notice</h3>
            <p id="modal-message" class="text-secondary mb-6 leading-relaxed text-base"></p>
            <button id="modal-close-btn" class="btn-primary">Close</button>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div id="confirm-modal" class="modal fixed inset-0 flex items-end hidden">
        <div class="modal-content w-full">
            <div class="modal-handle"></div>
            <h3 id="confirm-title" class="text-2xl font-bold mb-4" style="color: #ef4444;">‚ö†Ô∏è Warning</h3>
            <p id="confirm-message" class="text-secondary mb-6 leading-relaxed text-base">Confirm action?</p>
            <div class="space-y-3">
                <button id="confirm-ok-btn" class="btn-danger">Confirm</button>
                <button id="confirm-cancel-btn" class="nav-btn w-full">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal fixed inset-0 flex items-end hidden">
        <div class="modal-content w-full">
            <div class="modal-handle"></div>
            <h3 class="text-2xl font-bold text-light mb-4">‚öôÔ∏è Settings</h3>
            
            <!-- Reverse Mode Toggle (Moved into Settings) -->
            <div class="mb-6">
                <div class="settings-item-card">
                    <span class="settings-item-label">üîÑ Reverse Mode</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="reverse-mode-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <!-- Probability Settings -->
            <div class="mb-6">
                <p class="text-sm text-muted mb-4">Retest probability (total = 100%)</p>
                
                <div class="space-y-4">
                    <label class="block">
                        <span class="font-bold text-base flex items-center gap-2" style="color: #10b981;">
                            <span class="text-2xl">„Äá</span> Correct
                        </span>
                        <div class="flex items-center mt-2">
                            <input type="number" id="prob-correct" min="0" max="100" class="flex-1 p-3 text-lg font-bold text-right">
                            <span class="p-3 border-2 border-l-0 rounded-r-lg font-bold text-light" style="border-color: var(--input-border); background: var(--input-bg);">%</span>
                        </div>
                    </label>
                    
                    <label class="block">
                        <span class="font-bold text-base flex items-center gap-2" style="color: #fbbf24;">
                            <span class="text-2xl">‚ñ≥</span> Review
                        </span>
                        <div class="flex items-center mt-2">
                            <input type="number" id="prob-review" min="0" max="100" class="flex-1 p-3 text-lg font-bold text-right">
                            <span class="p-3 border-2 border-l-0 rounded-r-lg font-bold text-light" style="border-color: var(--input-border); background: var(--input-bg);">%</span>
                        </div>
                    </label>
                    
                    <label class="block">
                        <span class="font-bold text-base flex items-center gap-2" style="color: #ef4444;">
                            <span class="text-2xl">√ó</span> Incorrect
                        </span>
                        <div class="flex items-center mt-2">
                            <input type="number" id="prob-incorrect" min="0" max="100" class="flex-1 p-3 text-lg font-bold text-right">
                            <span class="p-3 border-2 border-l-0 rounded-r-lg font-bold text-light" style="border-color: var(--input-border); background: var(--input-bg);">%</span>
                        </div>
                    </label>
                    
                    <div class="text-center pt-2">
                        <p class="text-lg font-bold text-light">Total: <span id="prob-total" class="text-2xl" style="color: #06b6d4;">0%</span></p>
                    </div>
                </div>

                <button id="settings-save-btn" class="btn-primary mt-4" disabled>
                    Save Settings
                </button>
            </div>

            <!-- Add More Words -->
            <div class="border-t-2 border-opacity-20 pt-6 mt-6" style="border-color: var(--text-muted);">
                <h4 class="text-xl font-bold text-light mb-4">üìù Add Words</h4>
                <button id="goto-register-btn" class="btn-secondary mb-4">
                    ‚ûï Add More Words
                </button>
            </div>

            <!-- Delete Options -->
            <div class="border-t-2 border-opacity-20 pt-6 mt-6" style="border-color: var(--text-muted);">
                <h4 class="text-xl font-bold text-light mb-4">üóëÔ∏è Delete Words</h4>
                
                <div class="space-y-3 mb-4">
                    <label class="flex items-center gap-3 p-3 rounded-lg" style="background: var(--card-bg);">
                        <input type="checkbox" id="delete-correct-check">
                        <span class="text-light font-semibold">„Äá Correct (<span id="delete-correct-count">0</span>)</span>
                    </label>
                    
                    <label class="flex items-center gap-3 p-3 rounded-lg" style="background: var(--card-bg);">
                        <input type="checkbox" id="delete-review-check">
                        <span class="text-light font-semibold">‚ñ≥ Review (<span id="delete-review-count">0</span>)</span>
                    </label>
                    
                    <label class="flex items-center gap-3 p-3 rounded-lg" style="background: var(--card-bg);">
                        <input type="checkbox" id="delete-incorrect-check">
                        <span class="text-light font-semibold">√ó Incorrect (<span id="delete-incorrect-count">0</span>)</span>
                    </label>
                    
                    <label class="flex items-center gap-3 p-3 rounded-lg" style="background: var(--card-bg);">
                        <input type="checkbox" id="delete-unevaluated-check">
                        <span class="text-light font-semibold">‚àí Unevaluated (<span id="delete-unevaluated-count">0</span>)</span>
                    </label>
                </div>
                
                <button id="delete-by-status-btn" class="btn-danger mb-4" disabled>
                    Delete Selected
                </button>
                
                <button id="reset-data-btn" class="btn-danger">
                    Delete All Data
                </button>
            </div>
            
            <button id="settings-close-btn" class="nav-btn w-full mt-6">Close</button>
        </div>
    </div>

    <!-- Edit Word Modal -->
    <div id="edit-modal" class="modal fixed inset-0 flex items-end hidden">
        <div class="modal-content w-full">
            <div class="modal-handle"></div>
            <h3 class="text-2xl font-bold text-light mb-4">‚úèÔ∏è Edit Word</h3>
            
            <div class="space-y-4">
                <label class="block">
                    <span class="text-light font-semibold mb-2 block">Word</span>
                    <input type="text" id="edit-word-input" class="w-full p-3 text-lg" required>
                </label>
                
                <label class="block">
                    <span class="text-light font-semibold mb-2 block">Reading (optional)</span>
                    <input type="text" id="edit-reading-input" class="w-full p-3 text-lg">
                </label>
                
                <label class="block">
                    <span class="text-light font-semibold mb-2 block">Meaning</span>
                    <input type="text" id="edit-meaning-input" class="w-full p-3 text-lg" required>
                </label>
            </div>

            <div class="space-y-3 mt-6">
                <button id="edit-save-btn" class="btn-primary">Save</button>
                <button id="edit-cancel-btn" class="nav-btn w-full">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- Theme Management ---
        const LS_THEME_KEY = 'wordTest_theme';
        let currentTheme = localStorage.getItem(LS_THEME_KEY) || 'dark';
        
        function setTheme(theme) {
            currentTheme = theme;
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem(LS_THEME_KEY, theme);
            
            const themeToggle = document.getElementById('theme-toggle');
            themeToggle.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
        }
        
        document.getElementById('theme-toggle').addEventListener('click', () => {
            setTheme(currentTheme === 'dark' ? 'light' : 'dark');
        });
        
        setTheme(currentTheme);
        
        // --- localStorage Keys ---
        const LS_WORDS_KEY = 'wordTest_allWords';
        const LS_STATE_KEY = 'wordTest_state';

        // --- App State ---
        let state = {
            allWords: [],
            wordMap: new Map(),
            testPhase: 'unevaluated',
            unevaluatedWordIds: [],
            unevaluatedIndex: 0,
            wordStatuses: {},
            reviewWordPool: [],
            currentWord: null,
            previousWord: null, 
            wordHistory: [],
            historyIndex: -1,
            probabilities: {
                correct: 0.05,
                review: 0.30,
                incorrect: 0.65,
            },
            reverseMode: false,
            lastUpdated: null,
            fileName: null,
            answerVisible: false
        };

        // --- DOM Elements ---
        const $ = (id) => document.getElementById(id);
        const setupView = $('setup-view');
        const testView = $('test-view');
        const loadingIndicator = $('loading-indicator');
        const statusMessage = $('status-message');
        const wordInput = $('word-input');
        const saveWordsBtn = $('save-words-btn');
        const resumeTestBtn = $('resume-test-btn');
        const lastUpdatedTime = $('last-updated-time');
        const resumeInfo = $('resume-info');

        const questionDisplay = $('question-display');
        const questionWord = $('question-word');
        const answerSection = $('answer-section');
        const answerReading = $('answer-reading');
        const answerMeaning = $('answer-meaning');
        const wordDisplay = $('word-display');
        const reportButtons = $('report-buttons');
        const prevWordBtn = $('prev-word-btn');
        const nextWordBtn = $('next-word-btn');
        const editWordBtn = $('edit-word-btn');
        const reverseModeToggle = $('reverse-mode-toggle');
        
        const previousAnswerDisplay = $('previous-answer-display');
        const previousAnswerContentArea = $('previous-answer-content-area');

        const totalWordsCount = $('total-words-count');
        const unevaluatedCount = $('unevaluated-count');
        const correctCount = $('correct-count');
        const reviewCount = $('review-count');
        const incorrectCount = $('incorrect-count');
        
        const unevaluatedProgressBar = $('unevaluated-progress-bar');
        const unevaluatedProgressText = $('unevaluated-progress-text');
        const unevaluatedProgressSection = $('unevaluated-progress-section');
        const overallProgressBar = $('overall-progress-bar');
        const overallProgressText = $('overall-progress-text');

        const swipeLeft = $('swipe-left');
        const swipeRight = $('swipe-right');

        const customModal = $('custom-modal');
        const modalMessage = $('modal-message');
        const modalTitle = $('modal-title');
        const modalCloseBtn = $('modal-close-btn');
        
        const confirmModal = $('confirm-modal');
        const confirmTitle = $('confirm-title');
        const confirmMessage = $('confirm-message');
        const confirmOkBtn = $('confirm-ok-btn');
        const confirmCancelBtn = $('confirm-cancel-btn');

        const settingsModal = $('settings-modal');
        const openSettingsBtn = $('open-settings-btn');
        const settingsCloseBtn = $('settings-close-btn');
        const settingsSaveBtn = $('settings-save-btn');
        const probCorrectInput = $('prob-correct');
        const probReviewInput = $('prob-review');
        const probIncorrectInput = $('prob-incorrect');
        const probTotal = $('prob-total');
        const resetDataBtn = $('reset-data-btn');

        const deleteCorrectCheck = $('delete-correct-check');
        const deleteReviewCheck = $('delete-review-check');
        const deleteIncorrectCheck = $('delete-incorrect-check');
        const deleteUnevaluatedCheck = $('delete-unevaluated-check');
        const deleteCorrectCount = $('delete-correct-count');
        const deleteReviewCount = $('delete-review-count');
        const deleteIncorrectCount = $('delete-incorrect-count');
        const deleteUnevaluatedCount = $('delete-unevaluated-count');
        const deleteByStatusBtn = $('delete-by-status-btn');

        const editModal = $('edit-modal');
        const editWordInput = $('edit-word-input');
        const editReadingInput = $('edit-reading-input');
        const editMeaningInput = $('edit-meaning-input');
        const editSaveBtn = $('edit-save-btn');
        const editCancelBtn = $('edit-cancel-btn');
        
        const gotoRegisterBtn = $('goto-register-btn');

        // --- Touch/Swipe Handling ---
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        
        wordDisplay.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });
        
        wordDisplay.addEventListener('touchmove', (e) => {
            if (!state.answerVisible) return;
            
            const currentX = e.changedTouches[0].screenX;
            const diffX = currentX - touchStartX;
            
            wordDisplay.style.transform = `translateX(${diffX}px)`;
            wordDisplay.classList.add('swiping');
            
            if (diffX < -50) {
                swipeRight.classList.add('visible');
                swipeLeft.classList.remove('visible');
            } else if (diffX > 50) {
                swipeLeft.classList.add('visible');
                swipeRight.classList.remove('visible');
            } else {
                swipeLeft.classList.remove('visible');
                swipeRight.classList.remove('visible');
            }
        }, { passive: true });
        
        wordDisplay.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            
            const diffX = touchEndX - touchStartX;
            const diffY = Math.abs(touchEndY - touchStartY);
            
            wordDisplay.style.transform = '';
            wordDisplay.classList.remove('swiping');
            swipeLeft.classList.remove('visible');
            swipeRight.classList.remove('visible');
            
            if (diffY < 50 && state.answerVisible) {
                if (diffX > 100) {
                    if (!prevWordBtn.disabled) previousWord();
                } else if (diffX < -100) {
                    if (!nextWordBtn.disabled) nextWord();
                }
            }
        });
        
        // Tap to toggle answer
        questionDisplay.addEventListener('click', () => {
            if (state.answerVisible) {
                answerSection.classList.add('hidden');
                state.answerVisible = false;
            } else {
                answerSection.classList.remove('hidden');
                state.answerVisible = true;
            }
        });

        // --- Reverse Mode Toggle ---
        reverseModeToggle.addEventListener('change', (e) => {
            state.reverseMode = e.target.checked;
            saveTestState();
            if (state.currentWord) {
                displayWord(state.currentWord);
            }
            displayPreviousAnswer();
        });

        // --- UI Helper Functions ---
        function showModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            customModal.classList.remove('hidden');
        }
        
        modalCloseBtn.onclick = () => {
            customModal.classList.add('hidden');
        };
        
        function showConfirmModal(title, message, onConfirm) {
            confirmTitle.textContent = title;
            confirmMessage.textContent = message;
            confirmModal.classList.remove('hidden');
            
            const newOkBtn = confirmOkBtn.cloneNode(true);
            confirmOkBtn.parentNode.replaceChild(newOkBtn, confirmOkBtn);
            $('confirm-ok-btn').onclick = () => {
                onConfirm();
                confirmModal.classList.add('hidden');
            };
        }
        
        confirmCancelBtn.onclick = () => {
            confirmModal.classList.add('hidden');
        };

        function setView(viewName) {
            setupView.classList.add('hidden');
            testView.classList.add('hidden');
            loadingIndicator.classList.add('hidden');

            if (viewName === 'setup') {
                setupView.classList.remove('hidden');
            } else if (viewName === 'test') {
                testView.classList.remove('hidden');
            } else if (viewName === 'loading') {
                loadingIndicator.classList.remove('hidden');
            }
        }

        // --- localStorage Functions ---
        function createWordId(word, reading) {
            const str = word + (reading || '');
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return 'word_id_' + Math.abs(hash).toString(16);
        }

        function saveAllWords(words) {
            try {
                localStorage.setItem(LS_WORDS_KEY, JSON.stringify(words));
            } catch (e) {
                showModal('Error', 'Failed to save. Storage full?');
            }
        }

        function loadAllWords() {
            try {
                const json = localStorage.getItem(LS_WORDS_KEY);
                return json ? JSON.parse(json) : [];
            } catch (e) {
                return [];
            }
        }

        function saveTestState() {
            const timestamp = new Date();
            const saveData = {
                testPhase: state.testPhase,
                unevaluatedWordIds: state.unevaluatedWordIds,
                unevaluatedIndex: state.unevaluatedIndex,
                wordStatuses: state.wordStatuses,
                reviewWordPool: state.reviewWordPool,
                wordHistory: state.wordHistory,
                historyIndex: state.historyIndex,
                probabilities: state.probabilities,
                reverseMode: state.reverseMode,
                lastUpdated: timestamp.toISOString(),
                totalWordsCount: state.allWords.length,
                fileName: `Test_${timestamp.toISOString().replace(/[:.]/g, '-').slice(0, 19)}`
            };

            try {
                localStorage.setItem(LS_STATE_KEY, JSON.stringify(saveData));
                state.lastUpdated = saveData.lastUpdated;
                state.fileName = saveData.fileName;
                updateResumeButton(true);
            } catch (e) {
                showModal('Error', 'Failed to save state.');
            }
        }

        function loadTestState() {
            try {
                const json = localStorage.getItem(LS_STATE_KEY);
                return json ? JSON.parse(json) : null;
            } catch (e) {
                return null;
            }
        }
        
        function resetAppData() {
            localStorage.removeItem(LS_WORDS_KEY);
            localStorage.removeItem(LS_STATE_KEY);
            
            state.allWords = [];
            state.wordMap = new Map();
            state.testPhase = 'unevaluated';
            state.unevaluatedWordIds = [];
            state.unevaluatedIndex = 0;
            state.wordStatuses = {};
            state.reviewWordPool = [];
            state.currentWord = null;
            state.previousWord = null;
            state.wordHistory = [];
            state.historyIndex = -1;
            state.reverseMode = false;
            state.lastUpdated = null;
            state.fileName = null;
            state.answerVisible = false;

            settingsModal.classList.add('hidden');
            showModal('Reset Complete', 'All data deleted.');
            updateResumeButton(false);
            setView('setup');
            wordInput.value = '';
            updateStatsDisplay();
            if (previousAnswerDisplay) {
                previousAnswerDisplay.classList.add('hidden');
            }
        }

        function deleteWordsByStatus() {
            const selectedStatuses = [];
            if (deleteCorrectCheck.checked) selectedStatuses.push('correct');
            if (deleteReviewCheck.checked) selectedStatuses.push('review');
            if (deleteIncorrectCheck.checked) selectedStatuses.push('incorrect');
            if (deleteUnevaluatedCheck.checked) selectedStatuses.push('unevaluated');

            if (selectedStatuses.length === 0) {
                showModal('Error', 'Select at least one category.');
                return;
            }

            const wordsToDelete = state.allWords.filter(word => {
                const status = state.wordStatuses[word.id] || 'unevaluated';
                return selectedStatuses.includes(status);
            });

            if (wordsToDelete.length === 0) {
                showModal('Notice', 'No words match selection.');
                return;
            }

            showConfirmModal(
                '‚ö†Ô∏è Confirm',
                `Delete ${wordsToDelete.length} word(s)?`,
                () => {
                    const deleteIds = new Set(wordsToDelete.map(w => w.id));
                    state.allWords = state.allWords.filter(w => !deleteIds.has(w.id));
                    state.wordMap = new Map(state.allWords.map(w => [w.id, w]));
                    
                    deleteIds.forEach(id => delete state.wordStatuses[id]);
                    
                    state.unevaluatedWordIds = state.unevaluatedWordIds.filter(id => !deleteIds.has(id));
                    state.wordHistory = state.wordHistory.filter(id => !deleteIds.has(id));
                    
                    if (state.currentWord && deleteIds.has(state.currentWord.id)) {
                        state.currentWord = null;
                    }
                    
                    if (state.previousWord && deleteIds.has(state.previousWord.id)) {
                        state.previousWord = null;
                    }

                    saveAllWords(state.allWords);
                    
                    if (state.allWords.length === 0) {
                        resetAppData();
                    } else {
                        rebuildUnevaluatedList();
                        saveTestState();
                        settingsModal.classList.add('hidden');
                        showModal('‚úÖ Done', `${wordsToDelete.length} word(s) deleted.`);
                        startTest();
                        updateStatsDisplay();
                        updateDeleteCounts();
                    }
                }
            );
        }

        function updateDeleteCounts() {
            const counts = { correct: 0, review: 0, incorrect: 0, unevaluated: 0 };
            state.allWords.forEach(word => {
                const status = state.wordStatuses[word.id] || 'unevaluated';
                if (counts[status] !== undefined) counts[status]++;
            });

            deleteCorrectCount.textContent = counts.correct;
            deleteReviewCount.textContent = counts.review;
            deleteIncorrectCount.textContent = counts.incorrect;
            deleteUnevaluatedCount.textContent = counts.unevaluated;
        }

        function updateDeleteByStatusButton() {
            const anyChecked = deleteCorrectCheck.checked || 
                              deleteReviewCheck.checked || 
                              deleteIncorrectCheck.checked || 
                              deleteUnevaluatedCheck.checked;
            deleteByStatusBtn.disabled = !anyChecked;
        }

        [deleteCorrectCheck, deleteReviewCheck, deleteIncorrectCheck, deleteUnevaluatedCheck].forEach(checkbox => {
            checkbox.addEventListener('change', updateDeleteByStatusButton);
        });

        deleteByStatusBtn.addEventListener('click', deleteWordsByStatus);
        
        // --- Word Registration ---
        function rebuildUnevaluatedList() {
            state.unevaluatedWordIds = state.allWords
                .filter(word => !state.wordStatuses[word.id])
                .map(word => word.id);
            
            state.unevaluatedWordIds.sort((a, b) => {
                const wordA = state.wordMap.get(a);
                const wordB = state.wordMap.get(b);
                return (wordA.initialOrder || 0) - (wordB.initialOrder || 0);
            });

            if (state.unevaluatedIndex >= state.unevaluatedWordIds.length) {
                state.unevaluatedIndex = 0;
            }
            
            if (state.unevaluatedWordIds.length === 0) {
                const allCorrect = state.allWords.every(word => state.wordStatuses[word.id] === 'correct');
                state.testPhase = allCorrect ? 'finished' : 'retest';
            } else {
                state.testPhase = 'unevaluated';
            }
        }

        function handleSaveWords() {
            const rawText = wordInput.value.trim();
            if (!rawText) {
                showModal('Error', 'Enter words first.');
                return;
            }

            setView('loading');
            
            let existingWords = state.allWords;
            let existingWordMap = state.wordMap;
            
            let newWords = [...existingWords];
            let addedCount = 0;
            let skippedCount = 0;

            const lines = rawText.split('\n').filter(line => line.trim() !== '');

            for (let i = 0; i < lines.length; i++) {
                const parts = lines[i].split('_').map(part => part.trim());
                
                let word, reading, meaning;
                
                if (parts.length === 2) {
                    [word, meaning] = parts;
                    reading = '';
                } else if (parts.length === 3) {
                    [word, reading, meaning] = parts;
                } else {
                    skippedCount++;
                    continue;
                }
                
                const wordId = createWordId(word, reading);
                
                if (existingWordMap.has(wordId)) {
                    skippedCount++;
                    continue;
                }
                
                const newWordEntry = {
                    id: wordId,
                    word,
                    reading: reading || '',
                    meaning,
                    initialOrder: newWords.length,
                };
                
                newWords.push(newWordEntry);
                existingWordMap.set(wordId, newWordEntry);
                addedCount++;
            }

            if (skippedCount > 0) {
                showModal('Warning', `${skippedCount} skipped (duplicates/errors)`);
            }
            
            if (addedCount === 0) {
                showModal('Notice', 'No new words added.');
                setView('setup');
                return;
            }
            
            state.allWords = newWords;
            state.wordMap = existingWordMap;
            
            saveAllWords(newWords);
            rebuildUnevaluatedList();
            saveTestState();
            startTest();

            wordInput.value = '';
            showModal('Success', `Added ${addedCount} word(s)! Total: ${state.allWords.length}`);
        }

        // --- Test Logic ---
        function startTest() {
            if (state.allWords.length === 0) {
                showModal('Error', 'No words in database.');
                setView('setup');
                return;
            }
            
            setView('test');
            state.answerVisible = false;
            answerSection.classList.add('hidden');
            
            reverseModeToggle.checked = state.reverseMode;
            
            rebuildUnevaluatedList();
            
            if (state.testPhase === 'retest' && state.reviewWordPool.length === 0) {
                buildReviewWordPool();
            }
            
            if (!state.currentWord) {
                nextWord();
            } else {
                displayWord(state.currentWord);
            }
            updateNavigationButtons();
            updateStatsDisplay();
        }

        function nextWord() {
            if (state.historyIndex < state.wordHistory.length - 1) {
                state.historyIndex++;
                const wordId = state.wordHistory[state.historyIndex];
                state.currentWord = state.wordMap.get(wordId);
                if (!state.currentWord) {
                    state.wordHistory.splice(state.historyIndex, 1);
                    state.historyIndex--;
                    nextWord();
                    return;
                }
                displayWord(state.currentWord);
                updateNavigationButtons();
                return;
            }
            
            if (state.testPhase === 'unevaluated' && state.unevaluatedWordIds.length > 0) {
                if (state.unevaluatedIndex >= state.unevaluatedWordIds.length) {
                    rebuildUnevaluatedList();
                    
                    if (state.unevaluatedWordIds.length === 0) {
                        state.testPhase = 'retest';
                        showModal('üéâ Initial Complete!', 'Moving to review phase.');
                        buildReviewWordPool();
                        nextWord();
                        return;
                    }
                }
                
                const wordId = state.unevaluatedWordIds[state.unevaluatedIndex];
                state.currentWord = state.wordMap.get(wordId);
                state.unevaluatedIndex++;
                
            } else if (state.testPhase === 'retest') {
                if (state.reviewWordPool.length === 0) {
                    const allCorrect = state.allWords.every(word => state.wordStatuses[word.id] === 'correct');
                    if (allCorrect) {
                        state.testPhase = 'finished';
                        displayFinishedScreen();
                        saveTestState();
                        return;
                    }
                    buildReviewWordPool();
                    if (state.reviewWordPool.length === 0) {
                        displayFinishedScreen();
                        return;
                    }
                }

                const poolIndex = Math.floor(Math.random() * state.reviewWordPool.length);
                const wordId = state.reviewWordPool[poolIndex];
                state.currentWord = state.wordMap.get(wordId);
                
            } else if (state.testPhase === 'finished') {
                displayFinishedScreen();
                return;
            }
            
            if (!state.currentWord) {
                if (state.allWords.length > 0) {
                    state.currentWord = state.allWords[0];
                } else {
                    resetAppData();
                    return;
                }
            }

            if (state.historyIndex < state.wordHistory.length - 1) {
                state.wordHistory = state.wordHistory.slice(0, state.historyIndex + 1);
            }
            state.wordHistory.push(state.currentWord.id);
            state.historyIndex = state.wordHistory.length - 1;

            displayWord(state.currentWord);
            updateStatsDisplay();
            updateNavigationButtons();
            saveTestState();
        }
        
        function previousWord() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                const wordId = state.wordHistory[state.historyIndex];
                state.currentWord = state.wordMap.get(wordId);
                if (!state.currentWord) {
                    state.wordHistory.splice(state.historyIndex, 1);
                    previousWord();
                    return;
                }
                displayWord(state.currentWord);
                updateNavigationButtons();
            }
        }
        
        function updateNavigationButtons() {
            prevWordBtn.disabled = state.historyIndex <= 0;
            const atEndOfHistory = state.historyIndex >= state.wordHistory.length - 1;
            nextWordBtn.disabled = atEndOfHistory && (state.testPhase === 'finished' || (state.testPhase === 'unevaluated' && state.unevaluatedIndex >= state.unevaluatedWordIds.length));
        }
        
        function buildReviewWordPool() {
            const newPool = [];
            const { correct, review, incorrect } = state.probabilities;
            
            state.allWords.forEach(word => {
                const status = state.wordStatuses[word.id];
                if (!status) return;
                
                let probability = 0;
                if (status === 'correct') probability = correct;
                else if (status === 'review') probability = review;
                else if (status === 'incorrect') probability = incorrect;
                
                const frequency = Math.max(1, Math.round(probability * 100));
                for (let i = 0; i < frequency; i++) {
                    newPool.push(word.id);
                }
            });
            
            state.reviewWordPool = newPool;
        }

        function displayPreviousAnswer() {
            if (!state.previousWord) {
                previousAnswerDisplay.classList.add('hidden');
                return;
            }
            
            const prev = state.previousWord;
            previousAnswerDisplay.classList.remove('hidden');
            
            let contentHTML = '';
                
            if (state.reverseMode) {
                contentHTML += `<span class="previous-answer-main">${escapeHTML(prev.word)}</span>`;
                if (prev.reading) {
                    contentHTML += `<span class="previous-answer-sub">(${escapeHTML(prev.reading)})</span>`;
                }
            } else {
                contentHTML += `<span class="previous-answer-main">${escapeHTML(prev.meaning)}</span>`;
            }
            
            previousAnswerContentArea.innerHTML = contentHTML;
        }
        
        function escapeHTML(str) {
            return str.replace(/[&<>"']/g, function(match) {
                return {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                }[match];
            });
        }

        function displayWord(word) {
            state.answerVisible = false;
            answerSection.classList.add('hidden');
            
            displayPreviousAnswer();
                
            if (state.reverseMode) {
                questionWord.textContent = word.meaning;
                if (word.reading) {
                    answerReading.textContent = word.reading;
                    answerReading.style.display = 'block';
                } else {
                    answerReading.style.display = 'none';
                }
                answerMeaning.textContent = word.word;
            } else {
                questionWord.textContent = word.word;
                if (word.reading) {
                    answerReading.textContent = word.reading;
                    answerReading.style.display = 'block';
                } else {
                    answerReading.style.display = 'none';
                }
                answerMeaning.textContent = word.meaning;
            }
            
            if (state.testPhase !== 'finished') {
                reportButtons.style.display = 'grid';
            }
        }

        function displayFinishedScreen() {
            state.answerVisible = false;
            previousAnswerDisplay.classList.add('hidden');
            questionWord.textContent = 'ü•≥ Complete!';
            answerSection.classList.remove('hidden');
            answerReading.textContent = 'Great job!';
            answerReading.style.display = 'block';
            answerMeaning.textContent = 'All words marked correct!';
            reportButtons.style.display = 'none';
        }

        reportButtons.addEventListener('click', (e) => {
            const button = e.target.closest('button');
            if (!button || !state.currentWord) return;

            const result = button.dataset.result;
            state.wordStatuses[state.currentWord.id] = result;
            
            state.previousWord = state.currentWord;

            rebuildUnevaluatedList();
            
            if (state.testPhase === 'retest') {
                buildReviewWordPool();
            }
            
            nextWord();
        });

        prevWordBtn.addEventListener('click', previousWord);
        nextWordBtn.addEventListener('click', nextWord);

        // --- Edit Word ---
        editWordBtn.addEventListener('click', () => {
            if (!state.currentWord) return;
            editWordInput.value = state.currentWord.word;
            editReadingInput.value = state.currentWord.reading || '';
            editMeaningInput.value = state.currentWord.meaning;
            editModal.classList.remove('hidden');
        });

        editCancelBtn.addEventListener('click', () => {
            editModal.classList.add('hidden');
        });

        editSaveBtn.addEventListener('click', () => {
            const newWord = editWordInput.value.trim();
            const newReading = editReadingInput.value.trim();
            const newMeaning = editMeaningInput.value.trim();

            if (!newWord || !newMeaning) {
                showModal('Error', 'Word and meaning required.');
                return;
            }

            const oldId = state.currentWord.id;
            const newId = createWordId(newWord, newReading);

            if (newId !== oldId && state.wordMap.has(newId)) {
                showModal('Error', 'Word already exists.');
                return;
            }

            const wordIndex = state.allWords.findIndex(w => w.id === oldId);
            if (wordIndex !== -1) {
                if (newId !== oldId) {
                    if (state.wordStatuses[oldId]) {
                        state.wordStatuses[newId] = state.wordStatuses[oldId];
                        delete state.wordStatuses[oldId];
                    }
                    state.wordMap.delete(oldId);
                    
                    const unevalIdx = state.unevaluatedWordIds.indexOf(oldId);
                    if (unevalIdx !== -1) {
                        state.unevaluatedWordIds[unevalIdx] = newId;
                    }
                }

                state.allWords[wordIndex] = {
                    id: newId,
                    word: newWord,
                    reading: newReading,
                    meaning: newMeaning,
                    initialOrder: state.allWords[wordIndex].initialOrder
                };

                state.wordMap.set(newId, state.allWords[wordIndex]);
                state.currentWord = state.allWords[wordIndex];

                if (newId !== oldId) {
                    for (let i = 0; i < state.wordHistory.length; i++) {
                        if (state.wordHistory[i] === oldId) {
                            state.wordHistory[i] = newId;
                        }
                    }
                }

                saveAllWords(state.allWords);
                saveTestState();
                displayWord(state.currentWord);
                editModal.classList.add('hidden');
                showModal('Success', 'Word updated!');
                
                if (state.previousWord && state.previousWord.id === oldId) {
                    state.previousWord = state.currentWord;
                    displayPreviousAnswer();
                }
            }
        });

        // --- UI Updates ---
        function updateResumeButton(hasData) {
            if (hasData && state.allWords.length > 0) {
                resumeTestBtn.disabled = false;
                const date = new Date(state.lastUpdated);
                lastUpdatedTime.textContent = date.toLocaleString();
                resumeInfo.textContent = `${state.allWords.length} word(s)`;
                resumeTestBtn.onclick = startTest;
            } else {
                resumeTestBtn.disabled = true;
                lastUpdatedTime.textContent = '--';
                resumeInfo.textContent = 'No saved data';
                resumeTestBtn.onclick = null;
            }
        }

        function updateStatsDisplay() {
            const totalWords = state.allWords.length;
            const counts = { unevaluated: 0, correct: 0, review: 0, incorrect: 0 };
            
            state.allWords.forEach(word => {
                const status = state.wordStatuses[word.id] || 'unevaluated';
                if (counts[status] !== undefined) counts[status]++;
            });
            
            totalWordsCount.textContent = totalWords;
            unevaluatedCount.textContent = counts.unevaluated;
            correctCount.textContent = counts.correct;
            reviewCount.textContent = counts.review;
            incorrectCount.textContent = counts.incorrect;

            const evaluatedCount = totalWords - counts.unevaluated;
            const unevaluatedProgressPercent = totalWords > 0 ? (evaluatedCount / totalWords) * 100 : 0;
            unevaluatedProgressBar.style.width = `${unevaluatedProgressPercent}%`;
            unevaluatedProgressText.textContent = `${evaluatedCount} / ${totalWords}`;
            
            if (counts.unevaluated > 0) {
                unevaluatedProgressSection.style.display = 'block';
            } else {
                unevaluatedProgressSection.style.display = 'none';
            }
            
            const weightedProgress = counts.correct * 1 + counts.review * 0.5;
            const overallProgressPercent = totalWords > 0 ? (weightedProgress / totalWords) * 100 : 0;
            overallProgressBar.style.width = `${overallProgressPercent}%`;
            overallProgressText.textContent = `${weightedProgress.toFixed(1)} / ${totalWords}`;

            if (state.testPhase === 'unevaluated') {
                reportButtons.style.display = 'grid';
            } else if (state.testPhase === 'retest') {
                reportButtons.style.display = 'grid';
            } else if (state.testPhase === 'finished') {
                // No phase status display needed
            }
        }

        // --- Settings ---
        openSettingsBtn.onclick = () => {
            probCorrectInput.value = Math.round(state.probabilities.correct * 100);
            probReviewInput.value = Math.round(state.probabilities.review * 100);
            probIncorrectInput.value = Math.round(state.probabilities.incorrect * 100);
            updateProbabilityTotal();
            updateDeleteCounts();
            updateDeleteByStatusButton();
            reverseModeToggle.checked = state.reverseMode;
            settingsModal.classList.remove('hidden');
        };

        settingsCloseBtn.onclick = () => {
            settingsModal.classList.add('hidden');
        };

        [probCorrectInput, probReviewInput, probIncorrectInput].forEach(input => {
            input.addEventListener('input', updateProbabilityTotal);
        });

        function updateProbabilityTotal() {
            const c = parseInt(probCorrectInput.value) || 0;
            const r = parseInt(probReviewInput.value) || 0;
            const i = parseInt(probIncorrectInput.value) || 0;
            const total = c + r + i;

            probTotal.textContent = `${total}%`;
            if (total === 100) {
                probTotal.style.color = '#06b6d4';
                settingsSaveBtn.disabled = false;
            } else {
                probTotal.style.color = '#ef4444';
                settingsSaveBtn.disabled = true;
            }
        }

        settingsSaveBtn.onclick = () => {
            const c = parseInt(probCorrectInput.value);
            const r = parseInt(probReviewInput.value);
            const i = parseInt(probIncorrectInput.value);
            
            if (c + r + i !== 100) {
                showModal('Error', 'Total must equal 100%');
                return;
            }

            state.probabilities = {
                correct: c / 100,
                review: r / 100,
                incorrect: i / 100,
            };

            saveTestState();
            showModal('‚úÖ Saved', 'Settings updated!');
            settingsModal.classList.add('hidden');

            if (state.testPhase === 'retest') {
                buildReviewWordPool();
            }
        };
        
        resetDataBtn.onclick = () => {
            showConfirmModal(
                '‚ö†Ô∏è Warning',
                'Delete all data? Cannot be undone.',
                resetAppData
            );
        };

        gotoRegisterBtn.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
            setView('setup');
            wordInput.focus();
        });

        // --- Init ---
        function initApp() {
            setView('loading');

            const loadedWords = loadAllWords();
            if (loadedWords.length > 0) {
                state.allWords = loadedWords;
                state.wordMap = new Map(loadedWords.map(w => [w.id, w]));
            }

            const loadedState = loadTestState();
            if (loadedState && state.allWords.length > 0) {
                if (loadedState.totalWordsCount === state.allWords.length) {
                    Object.assign(state, loadedState);
                } else {
                    state.lastUpdated = loadedState.lastUpdated;
                }
                
                rebuildUnevaluatedList();
                updateStatsDisplay();
                updateResumeButton(true);
            } else {
                rebuildUnevaluatedList();
                updateResumeButton(false);
            }

            updateProbabilityTotal();
            setView('setup');
        }

        saveWordsBtn.addEventListener('click', handleSaveWords);

        window.onload = initApp;

        // Prevent zoom on double-tap
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>
