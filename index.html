<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0f">
    <title>Tango</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Plus Jakarta Sans', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'sans-serif'],
                    },
                    colors: {
                        surface: {
                            50: '#fafafa',
                            100: '#f4f4f5',
                            200: '#e4e4e7',
                            800: '#18181b',
                            850: '#121215',
                            900: '#0a0a0f',
                            950: '#050507',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        /* --- THEME DEFINITIONS --- */
        :root {
            /* Default Dark */
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --app-bg: #0a0a0f;
            --card-bg: rgba(24, 24, 27, 0.8);
            --card-border: rgba(63, 63, 70, 0.4);
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --accent-primary: #22d3ee;
            --accent-glow: rgba(34, 211, 238, 0.15);
            --modal-bg: #18181b;
        }

        [data-theme="light"] {
            --app-bg: #fafafa;
            --card-bg: rgba(255, 255, 255, 0.9);
            --card-border: rgba(228, 228, 231, 0.8);
            --text-primary: #18181b;
            --text-secondary: #52525b;
            --text-muted: #a1a1aa;
            --accent-primary: #0891b2;
            --accent-glow: rgba(8, 145, 178, 0.1);
            --modal-bg: #ffffff;
        }

        [data-theme="dark-blue"] {
            --app-bg: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.85);
            --card-border: rgba(71, 85, 105, 0.5);
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --accent-primary: #60a5fa;
            --accent-glow: rgba(96, 165, 250, 0.15);
            --modal-bg: #1e293b;
        }

        [data-theme="light-blue"] {
            --app-bg: #f0f9ff;
            --card-bg: rgba(255, 255, 255, 0.9);
            --card-border: rgba(186, 230, 253, 0.8);
            --text-primary: #0c4a6e;
            --text-secondary: #0284c7;
            --text-muted: #94a3b8;
            --accent-primary: #0ea5e9;
            --accent-glow: rgba(14, 165, 233, 0.15);
            --modal-bg: #ffffff;
        }

        [data-theme="light-green"] {
            --app-bg: #f0fdf4;
            --card-bg: rgba(255, 255, 255, 0.9);
            --card-border: rgba(187, 247, 208, 0.8);
            --text-primary: #14532d;
            --text-secondary: #16a34a;
            --text-muted: #94a3b8;
            --accent-primary: #22c55e;
            --accent-glow: rgba(34, 197, 94, 0.15);
            --modal-bg: #ffffff;
        }

        html {
            touch-action: manipulation;
            -webkit-text-size-adjust: 100%;
            overscroll-behavior: none;
        }

        body {
            font-family: 'Plus Jakarta Sans', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--app-bg);
            height: 100dvh;
            overflow: hidden;
            position: fixed;
            width: 100%;
            color: var(--text-primary);
            transition: background 0.3s ease, color 0.3s ease;
        }

        /* Ambient Background */
        .ambient-bg {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
            opacity: 0.6;
            background: 
                radial-gradient(ellipse 80% 50% at 20% 20%, var(--accent-glow), transparent),
                radial-gradient(ellipse 60% 40% at 80% 80%, var(--accent-glow), transparent);
            transition: opacity 0.5s ease;
        }

        /* App Container */
        .app-shell {
            position: relative;
            z-index: 1;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            padding: calc(12px + var(--safe-top)) 16px calc(12px + var(--safe-bottom));
            max-width: 480px;
            margin: 0 auto;
        }

        /* Glass Card */
        .glass {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--card-border);
            border-radius: 20px;
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        /* Header */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 4px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .header-left, .header-right {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 14px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            color: var(--text-primary);
        }

        .header-btn:active {
            transform: scale(0.92);
            opacity: 0.8;
        }

        .app-logo {
            font-size: 1.25rem;
            font-weight: 800;
            letter-spacing: -0.02em;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent-primary) 0%, #34d399 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            gap: 12px;
        }

        /* Previous Answer Bar */
        .prev-answer-bar {
            flex-shrink: 0;
            padding: 10px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            opacity: 0;
            transform: translateY(-8px);
            transition: all 0.3s ease;
        }

        .prev-answer-bar.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .prev-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .prev-content {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 60%;
        }

        .prev-sub {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-left: 6px;
        }

        /* Word Card */
        .word-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            position: relative;
            overflow: hidden;
            transition: transform 0.15s ease;
        }

        .word-card.swiping {
            transition: none;
        }

        .word-card.correct-flash { animation: flashCorrect 0.4s ease; }
        .word-card.review-flash { animation: flashReview 0.4s ease; }
        .word-card.incorrect-flash { animation: flashIncorrect 0.4s ease; }

        @keyframes flashCorrect { 0%, 100% { box-shadow: inset 0 0 0 0 transparent; } 50% { box-shadow: inset 0 0 0 4px rgba(52, 211, 153, 0.5); } }
        @keyframes flashReview { 0%, 100% { box-shadow: inset 0 0 0 0 transparent; } 50% { box-shadow: inset 0 0 0 4px rgba(251, 191, 36, 0.5); } }
        @keyframes flashIncorrect { 0%, 100% { box-shadow: inset 0 0 0 0 transparent; } 50% { box-shadow: inset 0 0 0 4px rgba(251, 113, 133, 0.5); } }

        /* Question Section */
        .question-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 24px 20px;
            cursor: pointer;
            user-select: none;
            min-height: 0;
            /* Scroll improvements */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .question-text {
            font-weight: 800;
            color: var(--text-primary);
            text-align: center;
            line-height: 1.4;
            max-width: 100%;
            margin-bottom: 8px;
            
            /* Text wrapping improvements */
            overflow-wrap: anywhere;
            word-break: break-word;
            hyphens: auto;
        }

        /* Auto Font Resizing Classes */
        .size-normal { font-size: clamp(1.5rem, 8vw, 2.5rem); }
        .size-medium { font-size: clamp(1.2rem, 6vw, 2.0rem); }
        .size-small { font-size: clamp(1.0rem, 5vw, 1.5rem); }
        .size-tiny { font-size: clamp(0.9rem, 4vw, 1.2rem); }

        .tap-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 16px;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
            transition: opacity 0.2s ease;
        }

        .tap-hint.hidden {
            display: none !important;
        }

        .tap-hint-icon { animation: tapPulse 2s ease-in-out infinite; }
        @keyframes tapPulse { 0%, 100% { opacity: 0.5; transform: scale(1); } 50% { opacity: 1; transform: scale(1.1); } }

        /* Word Info Chips */
        .word-chips {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            flex-wrap: wrap;
            justify-content: center;
            flex-shrink: 0;
            transition: opacity 0.2s ease;
        }

        .word-chips.hidden {
            display: none !important;
        }

        .chip {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .chip-neutral { background: rgba(113, 113, 122, 0.2); color: var(--text-secondary); }
        .chip-correct { background: rgba(52, 211, 153, 0.15); color: #34d399; }
        .chip-review { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .chip-incorrect { background: rgba(251, 113, 133, 0.15); color: #fb7185; }

        /* Answer Section */
        .answer-section {
            background: linear-gradient(180deg, transparent 0%, rgba(34, 211, 238, 0.03) 100%);
            border-top: 1px solid var(--card-border);
            padding: 20px;
            text-align: center;
            animation: slideUp 0.3s ease;
            flex-shrink: 0;
        }

        @keyframes slideUp { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }

        .answer-reading {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .answer-meaning {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.4;
            overflow-wrap: anywhere;
            word-break: break-word;
        }

        .edit-btn {
            margin-top: 12px;
            padding: 8px 16px;
            border-radius: 12px;
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
            font-size: 0.8rem;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        /* Report Buttons */
        .report-btns {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            flex-shrink: 0;
        }

        .report-btn {
            height: 64px;
            border-radius: 16px;
            border: none;
            font-size: 2rem;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            overflow: hidden;
        }
        .report-btn:active { transform: scale(0.94); }
        .report-btn::after {
            content: ''; position: absolute; inset: 0;
            background: linear-gradient(180deg, rgba(255,255,255,0.15) 0%, transparent 50%);
            pointer-events: none;
        }

        .btn-incorrect { background: linear-gradient(135deg, #fb7185 0%, #e11d48 100%); color: white; box-shadow: 0 4px 20px rgba(251, 113, 133, 0.3); }
        .btn-review { background: linear-gradient(135deg, #fbbf24 0%, #d97706 100%); color: white; box-shadow: 0 4px 20px rgba(251, 191, 36, 0.3); }
        .btn-correct { background: linear-gradient(135deg, #34d399 0%, #059669 100%); color: white; box-shadow: 0 4px 20px rgba(52, 211, 153, 0.3); }

        /* Navigation */
        .nav-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            flex-shrink: 0;
            margin-top: 10px;
        }

        .nav-btn {
            height: 48px;
            border-radius: 14px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        .nav-btn:active:not(:disabled) { transform: scale(0.96); opacity: 0.8; }
        .nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* Stats Bar */
        .stats-bar { flex-shrink: 0; padding: 12px 16px; margin-top: 10px; }
        .progress-row { margin-bottom: 10px; }
        .progress-label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
        .progress-title { font-size: 0.7rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
        .progress-value { font-size: 0.75rem; font-weight: 700; color: var(--text-secondary); }
        .progress-track { height: 6px; background: rgba(113, 113, 122, 0.2); border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; border-radius: 3px; transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .progress-fill-orange { background: linear-gradient(90deg, #fbbf24, #f59e0b); }
        .progress-fill-cyan { background: linear-gradient(90deg, #22d3ee, #06b6d4); }
        .stats-chips { display: flex; gap: 6px; justify-content: center; }
        .stat-chip { flex: 1; padding: 8px 4px; border-radius: 10px; text-align: center; font-size: 0.85rem; font-weight: 700; }
        .stat-chip-neutral { background: rgba(113, 113, 122, 0.15); color: var(--text-secondary); }
        .stat-chip-correct { background: rgba(52, 211, 153, 0.15); color: #34d399; }
        .stat-chip-review { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .stat-chip-incorrect { background: rgba(251, 113, 133, 0.15); color: #fb7185; }

        /* Setup View */
        .setup-view { flex: 1; display: flex; flex-direction: column; gap: 16px; overflow-y: auto; padding-bottom: 20px; }
        .setup-card { padding: 20px; }
        .setup-title { font-size: 1.1rem; font-weight: 700; color: var(--text-primary); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .setup-desc { font-size: 0.8rem; color: var(--text-muted); margin-bottom: 12px; }
        
        textarea {
            width: 100%; height: 140px; padding: 14px; border-radius: 14px;
            border: 1px solid var(--card-border); background: rgba(24, 24, 27, 0.5);
            color: var(--text-primary); font-family: inherit; font-size: 14px; resize: none; transition: all 0.2s ease;
        }
        [data-theme="light"] textarea, [data-theme="light-blue"] textarea, [data-theme="light-green"] textarea { background: rgba(244, 244, 245, 0.8); }
        
        textarea:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 3px var(--accent-glow); }
        textarea::placeholder { color: var(--text-muted); }
        
        .primary-btn {
            width: 100%; height: 52px; border-radius: 14px;
            background: linear-gradient(135deg, var(--accent-primary) 0%, #06b6d4 100%);
            color: white; font-size: 1rem; font-weight: 700; border: none; cursor: pointer; transition: all 0.15s ease;
            box-shadow: 0 4px 20px rgba(34, 211, 238, 0.3); margin-top: 12px;
        }
        .primary-btn:active:not(:disabled) { transform: scale(0.97); }
        .primary-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .secondary-btn {
            width: 100%; height: 52px; border-radius: 14px;
            background: linear-gradient(135deg, #34d399 0%, #059669 100%);
            color: white; font-size: 1rem; font-weight: 700; border: none; cursor: pointer; transition: all 0.15s ease;
            box-shadow: 0 4px 20px rgba(52, 211, 153, 0.3);
        }
        .secondary-btn:active:not(:disabled) { transform: scale(0.97); }
        .secondary-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Modals - UNIFIED STYLES */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
            z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s ease;
        }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        
        .modal-sheet {
            position: fixed; bottom: 0; left: 0; right: 0; max-height: 85dvh;
            background: var(--modal-bg);
            border: 1px solid var(--card-border); border-bottom: none;
            border-radius: 24px 24px 0 0; padding: 20px; padding-bottom: calc(20px + var(--safe-bottom));
            transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1001; overflow-y: auto; overscroll-behavior-y: contain;
        }
        .modal-overlay.active + .modal-sheet, .modal-sheet.active { transform: translateY(0); }
        
        /* High priority alerts */
        #confirm-modal-overlay, #message-modal-overlay { z-index: 2000; }
        #confirm-modal, #message-modal { z-index: 2001; }

        .modal-handle { width: 36px; height: 4px; background: var(--text-muted); border-radius: 2px; margin: 0 auto; opacity: 0.5; }
        .modal-drag-area { padding: 16px 0 12px; margin: -20px -20px 8px; cursor: grab; display: flex; flex-direction: column; align-items: center; border-radius: 24px 24px 0 0; }
        
        .modal-title { font-size: 1.25rem; font-weight: 700; color: var(--text-primary); margin-bottom: 16px; }
        .modal-message { font-size: 0.95rem; color: var(--text-secondary); line-height: 1.5; margin-bottom: 20px; white-space: pre-wrap; }
        
        .modal-btn { width: 100%; height: 50px; border-radius: 14px; font-size: 1rem; font-weight: 600; border: none; cursor: pointer; transition: all 0.15s ease; }
        .modal-btn:active { transform: scale(0.97); }
        .modal-btn-primary { background: var(--accent-primary); color: white; }
        .modal-btn-danger { background: linear-gradient(135deg, #fb7185 0%, #e11d48 100%); color: white; }
        .modal-btn-ghost { background: var(--card-bg); border: 1px solid var(--card-border); color: var(--text-primary); margin-top: 10px; }

        /* Theme Selection Modal */
        .theme-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        .theme-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            border-radius: 16px;
            border: 2px solid transparent;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .theme-option:active { transform: scale(0.98); }
        .theme-option.active {
            border-color: var(--accent-primary);
            background: var(--accent-glow);
        }
        .theme-preview {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .theme-color-dot {
            width: 32px; height: 32px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .theme-name {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .theme-check {
            color: var(--accent-primary);
            opacity: 0;
            font-weight: 800;
        }
        .theme-option.active .theme-check { opacity: 1; }

        /* Theme Color Dots */
        .dot-dark { background: #0a0a0f; }
        .dot-light { background: #fafafa; }
        .dot-dark-blue { background: #0f172a; }
        .dot-light-blue { background: #f0f9ff; }
        .dot-light-green { background: #f0fdf4; }

        /* Settings Items */
        .settings-item { display: flex; align-items: center; justify-content: space-between; padding: 14px; background: rgba(63, 63, 70, 0.15); border-radius: 14px; margin-bottom: 8px; }
        [data-theme="light"] .settings-item, [data-theme="light-blue"] .settings-item, [data-theme="light-green"] .settings-item { background: rgba(228, 228, 231, 0.5); }
        .settings-item-label { font-size: 0.95rem; font-weight: 600; color: var(--text-primary); }

        /* Toggle */
        .toggle { position: relative; width: 52px; height: 30px; }
        .toggle input { opacity: 0; width: 0; height: 0; }
        .toggle-track { position: absolute; inset: 0; background: rgba(113, 113, 122, 0.3); border-radius: 15px; transition: background 0.3s ease; }
        .toggle-thumb { position: absolute; top: 3px; left: 3px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: transform 0.3s ease; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); }
        .toggle input:checked + .toggle-track { background: var(--accent-primary); }
        .toggle input:checked + .toggle-track .toggle-thumb { transform: translateX(22px); }

        /* Probability Inputs */
        .prob-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 12px; }
        .prob-item { text-align: center; }
        .prob-label { font-size: 0.75rem; font-weight: 600; margin-bottom: 6px; }
        .prob-input { width: 100%; height: 44px; border-radius: 12px; border: 1px solid var(--card-border); background: rgba(24, 24, 27, 0.5); color: var(--text-primary); font-family: inherit; font-size: 1rem; font-weight: 700; text-align: center; }
        [data-theme="light"] .prob-input, [data-theme="light-blue"] .prob-input, [data-theme="light-green"] .prob-input { background: rgba(244, 244, 245, 0.8); }
        .prob-total { text-align: center; font-size: 0.9rem; font-weight: 700; margin-top: 8px; }
        .prob-total-valid { color: #34d399; } .prob-total-invalid { color: #fb7185; }

        /* Delete Options */
        .delete-option { display: flex; align-items: center; gap: 12px; padding: 12px; background: rgba(63, 63, 70, 0.15); border-radius: 12px; margin-bottom: 8px; cursor: pointer; }
        [data-theme="light"] .delete-option, [data-theme="light-blue"] .delete-option, [data-theme="light-green"] .delete-option { background: rgba(228, 228, 231, 0.5); }
        .delete-checkbox { width: 22px; height: 22px; border-radius: 6px; border: 2px solid var(--card-border); background: transparent; appearance: none; }
        .delete-checkbox:checked { background: #fb7185; border-color: #fb7185; }
        .delete-option-label { font-size: 0.9rem; font-weight: 600; color: var(--text-primary); }
        .danger-btn { width: 100%; height: 50px; border-radius: 14px; background: linear-gradient(135deg, #fb7185 0%, #e11d48 100%); color: white; font-size: 1rem; font-weight: 700; border: none; cursor: pointer; margin-top: 8px; }
        .danger-btn:active:not(:disabled) { transform: scale(0.97); }
        .danger-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* TTS Button */
        .tts-btn { position: absolute; bottom: 12px; right: 12px; width: 40px; height: 40px; border-radius: 12px; background: var(--accent-glow); border: 1px solid var(--accent-glow); color: var(--accent-primary); font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 10; transition: all 0.2s ease; }
        .tts-btn:active { transform: scale(0.9); }
        .tts-btn.speaking { animation: speakingPulse 0.8s ease-in-out infinite; }
        @keyframes speakingPulse { 0%, 100% { box-shadow: 0 0 0 0 var(--accent-glow); } 50% { box-shadow: 0 0 0 8px rgba(0,0,0,0); } }

        /* Word List */
        #wordlist-modal { height: 95dvh; display: flex; flex-direction: column; }
        .search-input { width: 100%; height: 44px; padding: 0 14px; border-radius: 12px; border: 1px solid var(--card-border); background: rgba(24, 24, 27, 0.5); color: var(--text-primary); font-size: 0.95rem; }
        [data-theme="light"] .search-input, [data-theme="light-blue"] .search-input, [data-theme="light-green"] .search-input { background: rgba(244, 244, 245, 0.8); }
        
        .word-item { display: flex; align-items: center; justify-content: space-between; padding: 14px; background: rgba(63, 63, 70, 0.15); border-radius: 14px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s ease; }
        [data-theme="light"] .word-item, [data-theme="light-blue"] .word-item, [data-theme="light-green"] .word-item { background: rgba(228, 228, 231, 0.5); }
        .word-item:active { transform: scale(0.98); opacity: 0.8; }
        
        .word-item-word { font-size: 1rem; font-weight: 700; color: var(--text-primary); }
        .word-item-detail { font-size: 0.8rem; color: var(--text-muted); }
        
        .status-unevaluated { background: rgba(113, 113, 122, 0.2); color: var(--text-secondary); }
        .status-correct { background: rgba(52, 211, 153, 0.2); color: #34d399; }
        .status-review { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
        .status-incorrect { background: rgba(251, 113, 133, 0.2); color: #fb7185; }
        
        /* Edit Modal Inputs */
        .edit-input { width: 100%; height: 48px; padding: 0 14px; border-radius: 12px; border: 1px solid var(--card-border); background: rgba(24, 24, 27, 0.5); color: var(--text-primary); font-size: 1rem; margin-bottom: 12px; }
        [data-theme="light"] .edit-input, [data-theme="light-blue"] .edit-input, [data-theme="light-green"] .edit-input { background: rgba(244, 244, 245, 0.8); }

        /* Utilities */
        .hidden { display: none !important; }
        .view-enter { animation: viewEnter 0.4s ease; }
        @keyframes viewEnter { from { opacity: 0; transform: translateY(16px); } to { opacity: 1; transform: translateY(0); } }
        ::-webkit-scrollbar { width: 0; height: 0; }

        /* Loading */
        .loading-view { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px; }
        .loading-dots { display: flex; gap: 8px; }
        .loading-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--accent-primary); animation: loadingBounce 0.6s infinite alternate; }
        .loading-dot:nth-child(2) { animation-delay: 0.2s; } .loading-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes loadingBounce { from { transform: translateY(0); } to { transform: translateY(-10px); } }

        /* Swipe Indicators */
        .swipe-indicator { position: fixed; top: 50%; transform: translateY(-50%); font-size: 2rem; opacity: 0; pointer-events: none; transition: opacity 0.2s ease; z-index: 100; color: var(--text-muted); }
        .swipe-indicator.left { left: 8px; } .swipe-indicator.right { right: 8px; } .swipe-indicator.visible { opacity: 0.5; }
    </style>
</head>
<body>
    <div class="ambient-bg"></div>

    <!-- Swipe Indicators -->
    <div id="swipe-left" class="swipe-indicator left">‚Äπ</div>
    <div id="swipe-right" class="swipe-indicator right">‚Ä∫</div>

    <div class="app-shell">
        <!-- Header -->
        <header class="app-header">
            <div class="header-left">
                <button id="settings-toggle" class="header-btn" aria-label="Settings">‚öôÔ∏è</button>
            </div>
            <div class="app-logo">
                <div class="logo-icon">üìö</div>
                <span>Tango</span>
            </div>
            <div class="header-right">
                <button id="wordlist-toggle" class="header-btn" aria-label="Word List">üìã</button>
                <button id="theme-toggle" class="header-btn" aria-label="Theme">üé®</button>
            </div>
        </header>

        <!-- Loading View -->
        <div id="loading-view" class="loading-view hidden">
            <div class="loading-dots">
                <div class="loading-dot"></div>
                <div class="loading-dot"></div>
                <div class="loading-dot"></div>
            </div>
            <p style="color: var(--text-muted);">Loading...</p>
        </div>

        <!-- Setup View -->
        <div id="setup-view" class="setup-view view-enter">
            <div class="setup-card glass">
                <h2 class="setup-title">üìù Register Words</h2>
                <p class="setup-desc">Format: word_reading_meaning or word_meaning</p>
                <textarea id="word-input" placeholder="„Çä„Çì„Åî_apple&#10;ÎÜÄÎã§_„Éé„É´„ÉÄ_ÈÅä„Å∂&#10;book_Êú¨"></textarea>
                <button id="save-words-btn" class="primary-btn">Add to Database</button>
            </div>

            <div class="setup-card glass">
                <h2 class="setup-title">üîÑ Resume Test</h2>
                <p id="resume-info" class="resume-info">No saved data</p>
                <button id="resume-test-btn" class="secondary-btn" disabled>
                    Resume (<span id="last-updated-time">--</span>)
                </button>
            </div>
        </div>

        <!-- Test View -->
        <div id="test-view" class="main-content hidden view-enter">
            <!-- Previous Answer -->
            <div id="prev-answer-bar" class="prev-answer-bar glass">
                <span class="prev-label">Prev Answer</span>
                <div id="prev-answer-content" class="prev-content"></div>
            </div>

            <!-- Word Card -->
            <div id="word-card" class="word-card glass">
                <div id="question-section" class="question-section">
                    <p id="question-text" class="question-text">Tap to Start</p>
                    <div id="tap-hint" class="tap-hint">
                        <span class="tap-hint-icon">üëÜ</span>
                        <span>Tap to reveal</span>
                    </div>
                    <div id="word-chips" class="word-chips hidden">
                        <span id="display-count-chip" class="chip chip-neutral">üëÅÔ∏è 0</span>
                        <span id="status-chip" class="chip chip-neutral">‚àí New</span>
                    </div>
                    <button id="tts-question-btn" class="tts-btn" aria-label="Read aloud">üîä</button>
                </div>
                <div id="answer-section" class="answer-section hidden">
                    <p id="answer-reading" class="answer-reading"></p>
                    <p id="answer-meaning" class="answer-meaning"></p>
                    <button id="edit-word-btn" class="edit-btn">‚úèÔ∏è Edit</button>
                    <button id="tts-answer-btn" class="tts-btn" aria-label="Read aloud">üîä</button>
                </div>
            </div>

            <!-- Report Buttons -->
            <div id="report-btns" class="report-btns">
                <button data-result="incorrect" class="report-btn btn-incorrect">‚úï</button>
                <button data-result="review" class="report-btn btn-review">‚ñ≥</button>
                <button data-result="correct" class="report-btn btn-correct">‚óã</button>
            </div>

            <!-- Navigation -->
            <div class="nav-row">
                <button id="prev-word-btn" class="nav-btn" disabled>‚Üê Back</button>
                <button id="next-word-btn" class="nav-btn">Next ‚Üí</button>
            </div>

            <!-- Stats Bar -->
            <div id="stats-bar" class="stats-bar glass">
                <div id="unevaluated-progress" class="progress-row">
                    <div class="progress-label">
                        <span class="progress-title">üìã New Words</span>
                        <span id="unevaluated-progress-text" class="progress-value">0 / 0</span>
                    </div>
                    <div class="progress-track">
                        <div id="unevaluated-progress-bar" class="progress-fill progress-fill-orange" style="width: 0%"></div>
                    </div>
                </div>
                <div class="progress-row">
                    <div class="progress-label">
                        <span class="progress-title">üìä Progress</span>
                        <span id="overall-progress-text" class="progress-value">0 / 0</span>
                    </div>
                    <div class="progress-track">
                        <div id="overall-progress-bar" class="progress-fill progress-fill-cyan" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stats-chips">
                    <div class="stat-chip stat-chip-neutral"><span id="unevaluated-count">0</span></div>
                    <div class="stat-chip stat-chip-correct"><span id="correct-count">0</span></div>
                    <div class="stat-chip stat-chip-review"><span id="review-count">0</span></div>
                    <div class="stat-chip stat-chip-incorrect"><span id="incorrect-count">0</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Theme Modal -->
    <div id="theme-modal-overlay" class="modal-overlay"></div>
    <div id="theme-modal" class="modal-sheet">
        <div class="modal-drag-area" data-modal="theme">
            <div class="modal-handle"></div>
            <span class="drag-hint">Swipe down to close</span>
        </div>
        <h3 class="modal-title">üé® Select Theme</h3>
        <div class="theme-grid">
            <div class="theme-option" data-value="dark">
                <div class="theme-preview"><div class="theme-color-dot dot-dark"></div><span class="theme-name">Dark</span></div><span class="theme-check">‚úì</span>
            </div>
            <div class="theme-option" data-value="light">
                <div class="theme-preview"><div class="theme-color-dot dot-light"></div><span class="theme-name">Light</span></div><span class="theme-check">‚úì</span>
            </div>
            <div class="theme-option" data-value="dark-blue">
                <div class="theme-preview"><div class="theme-color-dot dot-dark-blue"></div><span class="theme-name">Dark Blue</span></div><span class="theme-check">‚úì</span>
            </div>
            <div class="theme-option" data-value="light-blue">
                <div class="theme-preview"><div class="theme-color-dot dot-light-blue"></div><span class="theme-name">Light Blue</span></div><span class="theme-check">‚úì</span>
            </div>
            <div class="theme-option" data-value="light-green">
                <div class="theme-preview"><div class="theme-color-dot dot-light-green"></div><span class="theme-name">Light Green</span></div><span class="theme-check">‚úì</span>
            </div>
        </div>
        <button id="theme-close-btn" class="modal-btn modal-btn-ghost" style="margin-top: 16px;">Close</button>
    </div>

    <!-- Message Modal -->
    <div id="message-modal-overlay" class="modal-overlay"></div>
    <div id="message-modal" class="modal-sheet">
        <div class="modal-drag-area" data-modal="message">
            <div class="modal-handle"></div>
        </div>
        <h3 id="message-modal-title" class="modal-title">Notice</h3>
        <p id="message-modal-text" class="modal-message"></p>
        <button id="message-modal-close" class="modal-btn modal-btn-primary">OK</button>
    </div>

    <!-- Confirm Modal -->
    <div id="confirm-modal-overlay" class="modal-overlay"></div>
    <div id="confirm-modal" class="modal-sheet">
        <div class="modal-drag-area" data-modal="confirm">
            <div class="modal-handle"></div>
        </div>
        <h3 id="confirm-modal-title" class="modal-title">‚ö†Ô∏è Confirm</h3>
        <p id="confirm-modal-text" class="modal-message"></p>
        <button id="confirm-modal-ok" class="modal-btn modal-btn-danger">Confirm</button>
        <button id="confirm-modal-cancel" class="modal-btn modal-btn-ghost">Cancel</button>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal-overlay" class="modal-overlay"></div>
    <div id="settings-modal" class="modal-sheet">
        <div class="modal-drag-area" data-modal="settings">
            <div class="modal-handle"></div>
            <span class="drag-hint">Swipe down to close</span>
        </div>
        <h3 class="modal-title">‚öôÔ∏è Settings</h3>

        <div class="settings-section">
            <div class="settings-item">
                <span class="settings-item-label">üîÑ Reverse Mode</span>
                <label class="toggle">
                    <input type="checkbox" id="reverse-mode-toggle">
                    <div class="toggle-track"><div class="toggle-thumb"></div></div>
                </label>
            </div>
        </div>

        <div class="settings-section">
            <div class="settings-item">
                <span class="settings-item-label">üîä Auto Read (TTS)</span>
                <label class="toggle">
                    <input type="checkbox" id="tts-auto-toggle">
                    <div class="toggle-track"><div class="toggle-thumb"></div></div>
                </label>
            </div>
        </div>

        <div class="settings-section">
            <p style="font-size: 0.7rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; margin-bottom: 10px;">Review Probability</p>
            <div class="prob-grid">
                <div class="prob-item">
                    <p class="prob-label" style="color: #34d399;">‚óã Correct</p>
                    <input type="number" id="prob-correct" class="prob-input" min="0" max="100" value="5">
                </div>
                <div class="prob-item">
                    <p class="prob-label" style="color: #fbbf24;">‚ñ≥ Review</p>
                    <input type="number" id="prob-review" class="prob-input" min="0" max="100" value="30">
                </div>
                <div class="prob-item">
                    <p class="prob-label" style="color: #fb7185;">‚úï Incorrect</p>
                    <input type="number" id="prob-incorrect" class="prob-input" min="0" max="100" value="65">
                </div>
            </div>
            <p id="prob-total" class="prob-total prob-total-valid">Total: 100%</p>
            <button id="settings-save-btn" class="primary-btn" style="margin-top: 12px;">Save Settings</button>
        </div>

        <div class="settings-section">
            <button id="goto-register-btn" class="secondary-btn">‚ûï Add More Words</button>
        </div>

        <div class="settings-section">
            <p style="font-size: 0.7rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; margin-bottom: 10px;">Data Management</p>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <button id="export-json-btn" class="modal-btn" style="background: rgba(34,211,238,0.15); color: var(--accent-primary); border: 1px solid rgba(34,211,238,0.3);">üì§ JSON</button>
                <button id="export-csv-btn" class="modal-btn" style="background: rgba(34,211,238,0.15); color: var(--accent-primary); border: 1px solid rgba(34,211,238,0.3);">üì§ CSV</button>
            </div>
            <button id="import-btn" class="modal-btn" style="background: rgba(139,92,246,0.15); color: #a78bfa; border: 1px solid rgba(139,92,246,0.3); margin-top: 8px;">üì• Import File</button>
        </div>

        <div class="settings-section">
            <p style="font-size: 0.7rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; margin-bottom: 10px;">Delete by Status</p>
            <label class="delete-option">
                <input type="checkbox" id="delete-correct-check" class="delete-checkbox">
                <span class="delete-option-label">‚óã Correct (<span id="delete-correct-count">0</span>)</span>
            </label>
            <label class="delete-option">
                <input type="checkbox" id="delete-review-check" class="delete-checkbox">
                <span class="delete-option-label">‚ñ≥ Review (<span id="delete-review-count">0</span>)</span>
            </label>
            <label class="delete-option">
                <input type="checkbox" id="delete-incorrect-check" class="delete-checkbox">
                <span class="delete-option-label">‚úï Incorrect (<span id="delete-incorrect-count">0</span>)</span>
            </label>
            <label class="delete-option">
                <input type="checkbox" id="delete-unevaluated-check" class="delete-checkbox">
                <span class="delete-option-label">‚àí Unevaluated (<span id="delete-unevaluated-count">0</span>)</span>
            </label>
            <button id="delete-by-status-btn" class="danger-btn" disabled>Delete Selected</button>
        </div>

        <div class="settings-section">
            <button id="reset-data-btn" class="danger-btn">üóëÔ∏è Delete All Data</button>
        </div>

        <button id="settings-close-btn" class="modal-btn modal-btn-ghost" style="margin-top: 12px;">Close</button>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal-overlay" class="modal-overlay"></div>
    <div id="edit-modal" class="modal-sheet">
        <div class="modal-drag-area" data-modal="edit">
            <div class="modal-handle"></div>
            <span class="drag-hint">Swipe down to close</span>
        </div>
        <h3 class="modal-title">‚úèÔ∏è Edit Word</h3>
        <label style="font-size: 0.8rem; font-weight: 600; color: var(--text-muted); margin-bottom: 6px; display: block;">Word</label>
        <input type="text" id="edit-word-input" class="edit-input" required>
        <label style="font-size: 0.8rem; font-weight: 600; color: var(--text-muted); margin-bottom: 6px; display: block;">Reading (optional)</label>
        <input type="text" id="edit-reading-input" class="edit-input">
        <label style="font-size: 0.8rem; font-weight: 600; color: var(--text-muted); margin-bottom: 6px; display: block;">Meaning</label>
        <input type="text" id="edit-meaning-input" class="edit-input" required>
        <button id="edit-save-btn" class="modal-btn modal-btn-primary" style="margin-top: 8px;">Save</button>
        <button id="edit-cancel-btn" class="modal-btn modal-btn-ghost">Cancel</button>
    </div>

    <!-- Hidden File Input for Import -->
    <input type="file" id="import-file-input" class="file-input-hidden" accept=".json,.csv" style="display:none;">

    <!-- Word List Modal -->
    <div id="wordlist-modal-overlay" class="modal-overlay"></div>
    <div id="wordlist-modal" class="modal-sheet">
        <div style="flex-shrink: 0;">
            <div class="modal-drag-area" data-modal="wordlist">
                <div class="modal-handle"></div>
                <span class="drag-hint">Swipe down to close</span>
            </div>
            <h3 class="modal-title">üìã Word List</h3>
            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                <input type="text" id="wordlist-search" class="search-input" placeholder="üîç Search words...">
            </div>
            <div class="filter-chips" style="margin-bottom: 12px;">
                <button class="filter-chip active" data-filter="all">All</button>
                <button class="filter-chip" data-filter="unevaluated">‚àí New</button>
                <button class="filter-chip" data-filter="correct">‚óã</button>
                <button class="filter-chip" data-filter="review">‚ñ≥</button>
                <button class="filter-chip" data-filter="incorrect">‚úï</button>
            </div>
            <p id="wordlist-count" style="font-size: 0.75rem; color: var(--text-muted); text-align: center; margin-bottom: 8px;">0 words</p>
        </div>
        <div id="wordlist-container" style="flex: 1; overflow-y: auto; margin: 0 -20px; padding: 0 20px;"></div>
        <button id="wordlist-close-btn" class="modal-btn modal-btn-ghost" style="margin-top: 12px; flex-shrink: 0;">Close</button>
    </div>

    <script>
        // ============================================
        // Theme Management (Updated)
        // ============================================
        const LS_THEME_KEY = 'wordTest_theme_v2';
        let currentTheme = localStorage.getItem(LS_THEME_KEY) || 'dark';

        const themeToggleBtn = document.getElementById('theme-toggle');
        const themeModal = document.getElementById('theme-modal');
        const themeModalOverlay = document.getElementById('theme-modal-overlay');
        const themeCloseBtn = document.getElementById('theme-close-btn');
        const themeOptions = document.querySelectorAll('.theme-option');

        function setTheme(theme) {
            currentTheme = theme;
            
            // Set data-theme attribute
            if (theme === 'dark') {
                document.documentElement.removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', theme);
            }
            
            localStorage.setItem(LS_THEME_KEY, theme);
            
            // Update Meta Theme Color
            let metaColor = '#0a0a0f';
            switch(theme) {
                case 'light': metaColor = '#fafafa'; break;
                case 'dark-blue': metaColor = '#0f172a'; break;
                case 'light-blue': metaColor = '#f0f9ff'; break;
                case 'light-green': metaColor = '#f0fdf4'; break;
            }
            document.querySelector('meta[name="theme-color"]').setAttribute('content', metaColor);

            // Update Active State in Modal
            themeOptions.forEach(opt => {
                if (opt.dataset.value === theme) {
                    opt.classList.add('active');
                } else {
                    opt.classList.remove('active');
                }
            });
        }

        // Initialize Theme
        setTheme(currentTheme);

        // ============================================
        // Helper: Unified Modal Controller
        // ============================================
        function initModal(modalId, overlayId, triggerBtnId, closeBtnId, onOpen = null) {
            const modal = document.getElementById(modalId);
            const overlay = document.getElementById(overlayId);
            const trigger = document.getElementById(triggerBtnId);
            const close = document.getElementById(closeBtnId);
            
            if (!modal || !overlay) return () => {};

            // Open
            if(trigger) {
                trigger.addEventListener('click', () => {
                    overlay.classList.add('active');
                    modal.classList.add('active');
                    if(onOpen) onOpen();
                });
            }
            
            // Close Function
            const closeFn = () => {
                overlay.classList.remove('active');
                modal.classList.remove('active');
            };
            
            // Close Triggers
            if(close) close.addEventListener('click', closeFn);
            overlay.addEventListener('click', closeFn);
            
            return closeFn;
        }

        // Initialize Modals
        const closeSettingsFn = initModal('settings-modal', 'settings-modal-overlay', 'settings-toggle', 'settings-close-btn', () => {
            // Settings Open Logic
            probCorrectInput.value = Math.round(state.probabilities.correct * 100);
            probReviewInput.value = Math.round(state.probabilities.review * 100);
            probIncorrectInput.value = Math.round(state.probabilities.incorrect * 100);
            updateProbabilityTotal();
            updateDeleteCounts();
            updateDeleteByStatusButton();
            reverseModeToggle.checked = state.reverseMode;
        });

        const closeThemeFn = initModal('theme-modal', 'theme-modal-overlay', 'theme-toggle', 'theme-close-btn');
        
        const closeWordlistFn = initModal('wordlist-modal', 'wordlist-modal-overlay', 'wordlist-toggle', 'wordlist-close-btn', () => {
            renderWordlist();
        });

        // Theme Selection Click
        themeOptions.forEach(option => {
            option.addEventListener('click', () => {
                const selectedTheme = option.dataset.value;
                setTheme(selectedTheme);
                setTimeout(closeThemeFn, 200); // Close after selection
            });
        });


        // ============================================
        // LocalStorage Keys
        // ============================================
        const LS_WORDS_KEY = 'wordTest_allWords';
        const LS_STATE_KEY = 'wordTest_state';
        const LS_TTS_KEY = 'wordTest_tts';

        // ============================================
        // App State
        // ============================================
        let state = {
            allWords: [],
            wordMap: new Map(),
            testPhase: 'unevaluated',
            unevaluatedWordIds: [],
            unevaluatedIndex: 0,
            wordStatuses: {},
            wordDisplayCounts: {},
            currentWord: null,
            previousWord: null,
            wordHistory: [],
            historyIndex: -1,
            probabilities: { correct: 0.05, review: 0.30, incorrect: 0.65 },
            reverseMode: false,
            lastUpdated: null,
            fileName: null,
            answerVisible: false,
            editingFromList: null
        };

        // TTS State
        let ttsState = {
            autoRead: false,
            speed: 1.0,
            voices: [],
            speaking: false
        };

        // ============================================
        // DOM Elements
        // ============================================
        const $ = id => document.getElementById(id);

        const setupView = $('setup-view');
        const testView = $('test-view');
        const loadingView = $('loading-view');
        const wordInput = $('word-input');
        const saveWordsBtn = $('save-words-btn');
        const resumeTestBtn = $('resume-test-btn');
        const lastUpdatedTime = $('last-updated-time');
        const resumeInfo = $('resume-info');

        const wordCard = $('word-card');
        const questionSection = $('question-section');
        const questionText = $('question-text');
        const answerSection = $('answer-section');
        const answerReading = $('answer-reading');
        const answerMeaning = $('answer-meaning');
        
        // Chips & Hints
        const wordChips = $('word-chips');
        const displayCountChip = $('display-count-chip');
        const statusChip = $('status-chip');
        const tapHint = $('tap-hint');

        const prevAnswerBar = $('prev-answer-bar');
        const prevAnswerContent = $('prev-answer-content');

        const reportBtns = $('report-btns');
        const prevWordBtn = $('prev-word-btn');
        const nextWordBtn = $('next-word-btn');

        const statsBar = $('stats-bar');
        const unevaluatedProgress = $('unevaluated-progress');
        const unevaluatedProgressBar = $('unevaluated-progress-bar');
        const unevaluatedProgressText = $('unevaluated-progress-text');
        const overallProgressBar = $('overall-progress-bar');
        const overallProgressText = $('overall-progress-text');
        const unevaluatedCount = $('unevaluated-count');
        const correctCount = $('correct-count');
        const reviewCount = $('review-count');
        const incorrectCount = $('incorrect-count');

        const editWordBtn = $('edit-word-btn');
        const reverseModeToggle = $('reverse-mode-toggle');

        const settingsSaveBtn = $('settings-save-btn');
        const probCorrectInput = $('prob-correct');
        const probReviewInput = $('prob-review');
        const probIncorrectInput = $('prob-incorrect');
        const probTotal = $('prob-total');
        const resetDataBtn = $('reset-data-btn');
        const gotoRegisterBtn = $('goto-register-btn');

        const deleteCorrectCheck = $('delete-correct-check');
        const deleteReviewCheck = $('delete-review-check');
        const deleteIncorrectCheck = $('delete-incorrect-check');
        const deleteUnevaluatedCheck = $('delete-unevaluated-check');
        const deleteCorrectCount = $('delete-correct-count');
        const deleteReviewCount = $('delete-review-count');
        const deleteIncorrectCount = $('delete-incorrect-count');
        const deleteUnevaluatedCount = $('delete-unevaluated-count');
        const deleteByStatusBtn = $('delete-by-status-btn');

        const messageModalOverlay = $('message-modal-overlay');
        const messageModal = $('message-modal');
        const messageModalTitle = $('message-modal-title');
        const messageModalText = $('message-modal-text');
        const messageModalClose = $('message-modal-close');

        const confirmModalOverlay = $('confirm-modal-overlay');
        const confirmModal = $('confirm-modal');
        const confirmModalTitle = $('confirm-modal-title');
        const confirmModalText = $('confirm-modal-text');
        const confirmModalOk = $('confirm-modal-ok');
        const confirmModalCancel = $('confirm-modal-cancel');

        const editModalOverlay = $('edit-modal-overlay');
        const editModal = $('edit-modal');
        const editWordInput = $('edit-word-input');
        const editReadingInput = $('edit-reading-input');
        const editMeaningInput = $('edit-meaning-input');
        const editSaveBtn = $('edit-save-btn');
        const editCancelBtn = $('edit-cancel-btn');

        const swipeLeft = $('swipe-left');
        const swipeRight = $('swipe-right');

        const wordlistSearch = $('wordlist-search');
        const wordlistContainer = $('wordlist-container');
        const wordlistCount = $('wordlist-count');

        const ttsQuestionBtn = $('tts-question-btn');
        const ttsAnswerBtn = $('tts-answer-btn');
        const ttsAutoToggle = $('tts-auto-toggle');

        const exportJsonBtn = $('export-json-btn');
        const exportCsvBtn = $('export-csv-btn');
        const importBtn = $('import-btn');
        const importFileInput = $('import-file-input');

        // ============================================
        // Touch/Swipe Handling
        // ============================================
        let touchStartX = 0;
        let touchStartY = 0;

        wordCard.addEventListener('touchstart', e => {
            if (questionSection.contains(e.target) && questionSection.scrollHeight > questionSection.clientHeight) return;
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        wordCard.addEventListener('touchmove', e => {
            if (!state.answerVisible) return;
            if (questionSection.contains(e.target) && questionSection.scrollHeight > questionSection.clientHeight) return;
            
            const currentX = e.changedTouches[0].screenX;
            const diffX = currentX - touchStartX;
            
            if (Math.abs(diffX) > Math.abs(e.changedTouches[0].screenY - touchStartY)) {
                wordCard.style.transform = `translateX(${diffX * 0.3}px)`;
                wordCard.classList.add('swiping');
                if (diffX < -40) {
                    swipeRight.classList.add('visible');
                    swipeLeft.classList.remove('visible');
                } else if (diffX > 40) {
                    swipeLeft.classList.add('visible');
                    swipeRight.classList.remove('visible');
                } else {
                    swipeLeft.classList.remove('visible');
                    swipeRight.classList.remove('visible');
                }
            }
        }, { passive: true });

        wordCard.addEventListener('touchend', e => {
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            const diffX = touchEndX - touchStartX;
            const diffY = Math.abs(touchEndY - touchStartY);
            
            wordCard.style.transform = '';
            wordCard.classList.remove('swiping');
            swipeLeft.classList.remove('visible');
            swipeRight.classList.remove('visible');
            
            if (questionSection.contains(e.target) && questionSection.scrollHeight > questionSection.clientHeight && diffY > 10) return;
            
            if (diffY < 50 && state.answerVisible) {
                if (diffX > 80 && !prevWordBtn.disabled) previousWord();
                else if (diffX < -80 && !nextWordBtn.disabled) nextWord();
            }
        });

        // Question Click Handler
        questionSection.addEventListener('click', (e) => {
            if (window.getSelection().toString().length > 0) return;
            
            if (state.answerVisible) {
                answerSection.classList.add('hidden');
                state.answerVisible = false;
                wordChips.classList.remove('hidden');
                tapHint.classList.remove('hidden');
            } else {
                answerSection.classList.remove('hidden');
                state.answerVisible = true;
                wordChips.classList.add('hidden');
                tapHint.classList.add('hidden');
            }
        });

        // ============================================
        // Helpers & Modal
        // ============================================
        function showModal(title, message) {
            messageModalTitle.textContent = title;
            messageModalText.textContent = message;
            messageModalOverlay.classList.add('active');
            messageModal.classList.add('active');
        }

        messageModalClose.onclick = () => {
            messageModalOverlay.classList.remove('active');
            messageModal.classList.remove('active');
        };
        messageModalOverlay.onclick = () => {
            messageModalOverlay.classList.remove('active');
            messageModal.classList.remove('active');
        };

        let confirmCallback = null;
        function showConfirmModal(title, message, onConfirm) {
            confirmModalTitle.textContent = title;
            confirmModalText.textContent = message;
            confirmCallback = onConfirm;
            confirmModalOverlay.classList.add('active');
            confirmModal.classList.add('active');
        }

        confirmModalOk.onclick = () => {
            if (confirmCallback) confirmCallback();
            confirmModalOverlay.classList.remove('active');
            confirmModal.classList.remove('active');
        };
        confirmModalCancel.onclick = () => {
            confirmModalOverlay.classList.remove('active');
            confirmModal.classList.remove('active');
        };
        confirmModalOverlay.onclick = () => {
            confirmModalOverlay.classList.remove('active');
            confirmModal.classList.remove('active');
        };

        function setView(viewName) {
            setupView.classList.add('hidden');
            testView.classList.add('hidden');
            loadingView.classList.add('hidden');

            if (viewName === 'setup') setupView.classList.remove('hidden');
            else if (viewName === 'test') testView.classList.remove('hidden');
            else if (viewName === 'loading') loadingView.classList.remove('hidden');
        }

        // ============================================
        // Core Logic
        // ============================================
        function createWordId(word, reading) {
            const str = word + (reading || '');
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash = hash & hash;
            }
            return 'word_id_' + Math.abs(hash).toString(16);
        }

        function saveAllWords(words) {
            try {
                localStorage.setItem(LS_WORDS_KEY, JSON.stringify(words));
            } catch (e) {
                showModal('Error', 'Failed to save. Storage full?');
            }
        }

        function loadAllWords() {
            try {
                const json = localStorage.getItem(LS_WORDS_KEY);
                return json ? JSON.parse(json) : [];
            } catch (e) {
                return [];
            }
        }

        function saveTestState() {
            const timestamp = new Date();
            const saveData = {
                testPhase: state.testPhase,
                unevaluatedWordIds: state.unevaluatedWordIds,
                unevaluatedIndex: state.unevaluatedIndex,
                wordStatuses: state.wordStatuses,
                wordDisplayCounts: state.wordDisplayCounts,
                wordHistory: state.wordHistory,
                historyIndex: state.historyIndex,
                probabilities: state.probabilities,
                reverseMode: state.reverseMode,
                lastUpdated: timestamp.toISOString(),
                totalWordsCount: state.allWords.length,
                fileName: `Test_${timestamp.toISOString().replace(/[:.]/g, '-').slice(0, 19)}`
            };
            try {
                localStorage.setItem(LS_STATE_KEY, JSON.stringify(saveData));
                state.lastUpdated = saveData.lastUpdated;
                state.fileName = saveData.fileName;
                updateResumeButton(true);
            } catch (e) {
                showModal('Error', 'Failed to save state.');
            }
        }

        function loadTestState() {
            try {
                const json = localStorage.getItem(LS_STATE_KEY);
                return json ? JSON.parse(json) : null;
            } catch (e) {
                return null;
            }
        }

        function resetAppData() {
            localStorage.removeItem(LS_WORDS_KEY);
            localStorage.removeItem(LS_STATE_KEY);
            state = {
                allWords: [],
                wordMap: new Map(),
                testPhase: 'unevaluated',
                unevaluatedWordIds: [],
                unevaluatedIndex: 0,
                wordStatuses: {},
                wordDisplayCounts: {},
                currentWord: null,
                previousWord: null,
                wordHistory: [],
                historyIndex: -1,
                probabilities: state.probabilities,
                reverseMode: false,
                lastUpdated: null,
                fileName: null,
                answerVisible: false,
                editingFromList: null
            };
            closeSettingsFn();
            showModal('Reset Complete', 'All data deleted.');
            updateResumeButton(false);
            setView('setup');
            wordInput.value = '';
            updateStatsDisplay();
            prevAnswerBar.classList.remove('visible');
        }

        // Delete Logic
        function deleteWordsByStatus() {
            const selectedStatuses = [];
            if (deleteCorrectCheck.checked) selectedStatuses.push('correct');
            if (deleteReviewCheck.checked) selectedStatuses.push('review');
            if (deleteIncorrectCheck.checked) selectedStatuses.push('incorrect');
            if (deleteUnevaluatedCheck.checked) selectedStatuses.push('unevaluated');
            
            if (selectedStatuses.length === 0) {
                showModal('Error', 'Select at least one category.');
                return;
            }
            
            const wordsToDelete = state.allWords.filter(word => selectedStatuses.includes(state.wordStatuses[word.id] || 'unevaluated'));
            
            if (wordsToDelete.length === 0) {
                showModal('Notice', 'No words match selection.');
                return;
            }
            
            showConfirmModal('‚ö†Ô∏è Confirm', `Delete ${wordsToDelete.length} word(s)?`, () => {
                const deleteIds = new Set(wordsToDelete.map(w => w.id));
                state.allWords = state.allWords.filter(w => !deleteIds.has(w.id));
                state.wordMap = new Map(state.allWords.map(w => [w.id, w]));
                
                deleteIds.forEach(id => {
                    delete state.wordStatuses[id];
                    delete state.wordDisplayCounts[id];
                });
                
                state.unevaluatedWordIds = state.unevaluatedWordIds.filter(id => !deleteIds.has(id));
                state.wordHistory = state.wordHistory.filter(id => !deleteIds.has(id));
                
                if (state.currentWord && deleteIds.has(state.currentWord.id)) state.currentWord = null;
                if (state.previousWord && deleteIds.has(state.previousWord.id)) state.previousWord = null;
                
                saveAllWords(state.allWords);
                
                if (state.allWords.length === 0) {
                    resetAppData();
                } else {
                    rebuildUnevaluatedList();
                    saveTestState();
                    closeSettingsFn();
                    showModal('‚úÖ Done', `Deleted.`);
                    startTest();
                    updateStatsDisplay();
                    updateDeleteCounts();
                }
            });
        }

        function updateDeleteCounts() {
            const counts = { correct: 0, review: 0, incorrect: 0, unevaluated: 0 };
            state.allWords.forEach(word => {
                const status = state.wordStatuses[word.id] || 'unevaluated';
                if (counts[status] !== undefined) counts[status]++;
            });
            deleteCorrectCount.textContent = counts.correct;
            deleteReviewCount.textContent = counts.review;
            deleteIncorrectCount.textContent = counts.incorrect;
            deleteUnevaluatedCount.textContent = counts.unevaluated;
        }

        function updateDeleteByStatusButton() {
            deleteByStatusBtn.disabled = !(deleteCorrectCheck.checked || deleteReviewCheck.checked || deleteIncorrectCheck.checked || deleteUnevaluatedCheck.checked);
        }
        
        [deleteCorrectCheck, deleteReviewCheck, deleteIncorrectCheck, deleteUnevaluatedCheck].forEach(cb => cb.addEventListener('change', updateDeleteByStatusButton));
        deleteByStatusBtn.addEventListener('click', deleteWordsByStatus);

        // Word Registration
        function rebuildUnevaluatedList() {
            state.unevaluatedWordIds = state.allWords.filter(word => !state.wordStatuses[word.id]).map(word => word.id);
            state.unevaluatedWordIds.sort((a, b) => (state.wordMap.get(a).initialOrder || 0) - (state.wordMap.get(b).initialOrder || 0));
            
            if (state.unevaluatedIndex >= state.unevaluatedWordIds.length) state.unevaluatedIndex = 0;
            
            if (state.unevaluatedWordIds.length === 0) {
                state.testPhase = state.allWords.every(word => state.wordStatuses[word.id] === 'correct') ? 'finished' : 'retest';
            } else {
                state.testPhase = 'unevaluated';
            }
        }

        // --- NEW: Transparent Registration Logic ---
        function handleSaveWords() {
            const rawText = wordInput.value.trim();
            if (!rawText) { showModal('Error', 'Enter words first.'); return; }
            
            setView('loading');
            
            const lines = rawText.split('\n');
            const newWords = [...state.allWords];
            let successCount = 0;
            let skippedCount = 0;
            let errorDetails = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Parse Strategy: Tab > | > _ > Multiple Spaces > Single Space (Fallback, Careful!)
                let parts;
                if (line.includes('\t')) parts = line.split('\t');
                else if (line.includes('|')) parts = line.split('|');
                else if (line.includes('_')) parts = line.split('_');
                else {
                    // Try splitting by 2 or more spaces first (Safest for "give up  yameru")
                    const multiSpaceParts = line.split(/\s{2,}/);
                    if (multiSpaceParts.length >= 2) {
                        parts = multiSpaceParts;
                    } else {
                         // Fallback: Split by any space, BUT check if it results in valid count (2 or 3)
                         // This allows "word meaning" but might break "give up meaning" -> "give", "up", "meaning" (3 parts, OK)
                         // But "give up meaning desc" -> 4 parts (Error)
                         parts = line.split(/\s+/);
                         if (parts.length < 2) {
                             errorDetails.push(`Line ${i+1}: '${line}' (No separator found)`);
                             continue;
                         }
                    }
                }

                parts = parts.map(p => p.trim()).filter(p => p);
                
                if (parts.length < 2) {
                    errorDetails.push(`Line ${i+1}: '${line}' (Needs word and meaning)`);
                    continue;
                }
                
                if (parts.length > 3) {
                     // Try to merge extra parts if they were split by single spaces unintentionally?
                     // No, better to error out than guess wrong.
                     errorDetails.push(`Line ${i+1}: '${line}' (Too many parts: ${parts.length})`);
                     continue;
                }

                let word, reading, meaning;
                if (parts.length === 2) {
                    [word, meaning] = parts;
                    reading = '';
                } else {
                    [word, reading, meaning] = parts;
                }

                const wordId = createWordId(word, reading);
                
                if (state.wordMap.has(wordId)) {
                    skippedCount++;
                    continue;
                }

                const newWordEntry = { id: wordId, word, reading: reading || '', meaning, initialOrder: newWords.length };
                newWords.push(newWordEntry);
                state.wordMap.set(wordId, newWordEntry);
                successCount++;
            }
            
            state.allWords = newWords;
            saveAllWords(newWords);
            rebuildUnevaluatedList();
            saveTestState();
            
            // Generate Report
            let reportMsg = `Success: ${successCount}\nSkipped (Duplicate): ${skippedCount}`;
            if (errorDetails.length > 0) {
                reportMsg += `\nErrors: ${errorDetails.length}\n\n[Error Details]\n${errorDetails.slice(0, 5).join('\n')}`;
                if (errorDetails.length > 5) reportMsg += `\n...and ${errorDetails.length - 5} more.`;
            }

            if (successCount > 0) {
                startTest();
                wordInput.value = '';
            } else {
                setView('setup');
            }
            
            showModal('Registration Report', reportMsg);
        }

        saveWordsBtn.addEventListener('click', handleSaveWords);

        // --- NEW: Weighted Random Logic ---
        function getWeightedRandomWord() {
            const candidates = [];
            let totalWeight = 0;
            
            state.allWords.forEach(word => {
                const status = state.wordStatuses[word.id];
                if (!status) return; // Only reviewed words
                
                let weight = 0;
                if (status === 'correct') weight = state.probabilities.correct;
                else if (status === 'review') weight = state.probabilities.review;
                else if (status === 'incorrect') weight = state.probabilities.incorrect;
                
                if (weight > 0) {
                    candidates.push({ word, weight });
                    totalWeight += weight;
                }
            });

            if (candidates.length === 0) return null;

            let random = Math.random() * totalWeight;
            for (const candidate of candidates) {
                random -= candidate.weight;
                if (random <= 0) return candidate.word;
            }
            return candidates[candidates.length - 1].word;
        }

        // Test Loop
        function startTest() {
            if (state.allWords.length === 0) {
                showModal('Error', 'No words.');
                setView('setup');
                return;
            }
            
            setView('test');
            state.answerVisible = false;
            answerSection.classList.add('hidden');
            reverseModeToggle.checked = state.reverseMode;
            
            rebuildUnevaluatedList();
            
            if (!state.currentWord) {
                nextWord();
            } else {
                displayWord(state.currentWord);
            }
            
            updateNavigationButtons();
            updateStatsDisplay();
        }

        function nextWord() {
            if (state.historyIndex < state.wordHistory.length - 1) {
                state.historyIndex++;
                state.currentWord = state.wordMap.get(state.wordHistory[state.historyIndex]);
                if (!state.currentWord) {
                    state.wordHistory.splice(state.historyIndex, 1);
                    state.historyIndex--;
                    nextWord();
                    return;
                }
                displayWord(state.currentWord);
                updateNavigationButtons();
                return;
            }
            
            if (state.testPhase === 'unevaluated' && state.unevaluatedWordIds.length > 0) {
                if (state.unevaluatedIndex >= state.unevaluatedWordIds.length) {
                    rebuildUnevaluatedList();
                    if (state.unevaluatedWordIds.length === 0) {
                        state.testPhase = 'retest';
                        showModal('üéâ Phase 1 Complete', 'Review Mode');
                        nextWord();
                        return;
                    }
                }
                state.currentWord = state.wordMap.get(state.unevaluatedWordIds[state.unevaluatedIndex]);
                state.unevaluatedIndex++;
            } else if (state.testPhase === 'retest') {
                const word = getWeightedRandomWord();
                if (!word) {
                      if (state.allWords.every(word => state.wordStatuses[word.id] === 'correct')) {
                        state.testPhase = 'finished';
                        displayFinishedScreen();
                        saveTestState();
                        return;
                    }
                    displayFinishedScreen();
                    return;
                }
                state.currentWord = word;
            } else if (state.testPhase === 'finished') {
                displayFinishedScreen();
                return;
            }
            
            if (!state.currentWord) {
                if (state.allWords.length > 0) {
                    state.currentWord = state.allWords[0];
                } else {
                    resetAppData();
                    return;
                }
            }
            
            if (state.historyIndex < state.wordHistory.length - 1) {
                state.wordHistory = state.wordHistory.slice(0, state.historyIndex + 1);
            }
            
            state.wordHistory.push(state.currentWord.id);
            state.historyIndex = state.wordHistory.length - 1;
            
            incrementDisplayCount(state.currentWord);
            displayWord(state.currentWord);
            updateStatsDisplay();
            updateNavigationButtons();
            saveTestState();
        }

        function previousWord() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                state.currentWord = state.wordMap.get(state.wordHistory[state.historyIndex]);
                if (!state.currentWord) {
                    state.wordHistory.splice(state.historyIndex, 1);
                    previousWord();
                    return;
                }
                displayWord(state.currentWord);
                updateNavigationButtons();
            }
        }

        function updateNavigationButtons() {
            prevWordBtn.disabled = state.historyIndex <= 0;
            nextWordBtn.disabled = false;
        }

        function escapeHTML(str) {
            return str.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
        }

        function displayPreviousAnswer() {
            if (!state.previousWord) {
                prevAnswerBar.classList.remove('visible');
                return;
            }
            prevAnswerBar.classList.add('visible');
            const txt = state.reverseMode ? `${escapeHTML(state.previousWord.word)} <span class="prev-sub">(${escapeHTML(state.previousWord.reading || '')})</span>` : escapeHTML(state.previousWord.meaning);
            prevAnswerContent.innerHTML = txt;
        }

        function incrementDisplayCount(word) {
            if (!word) return;
            state.wordDisplayCounts[word.id] = (state.wordDisplayCounts[word.id] || 0) + 1;
        }

        function updateWordChips(word) {
            if (!word) {
                wordChips.classList.add('hidden');
                return;
            }
            const status = state.wordStatuses[word.id] || 'unevaluated';
            displayCountChip.textContent = `üëÅÔ∏è ${state.wordDisplayCounts[word.id] || 0}`;
            
            let statusText = '‚àí New';
            let statusClass = 'chip-neutral';
            
            if (status === 'correct') { statusText = '‚óã Correct'; statusClass = 'chip-correct'; }
            else if (status === 'review') { statusText = '‚ñ≥ Review'; statusClass = 'chip-review'; }
            else if (status === 'incorrect') { statusText = '‚úï Incorrect'; statusClass = 'chip-incorrect'; }
            
            statusChip.textContent = statusText;
            statusChip.className = `chip ${statusClass}`;
        }

        // Font Size Adjustment logic
        function adjustFontSize(element, text) {
            element.classList.remove('size-normal', 'size-medium', 'size-small', 'size-tiny');
            const len = text.length;
            if (len > 60) element.classList.add('size-tiny');
            else if (len > 30) element.classList.add('size-small');
            else if (len > 15) element.classList.add('size-medium');
            else element.classList.add('size-normal');
        }

        function displayWord(word) {
            state.answerVisible = false;
            answerSection.classList.add('hidden');
            
            wordChips.classList.remove('hidden');
            tapHint.classList.remove('hidden');

            displayPreviousAnswer();
            updateWordChips(word);
            
            let displayText = state.reverseMode ? word.meaning : word.word;
            questionText.textContent = displayText;
            adjustFontSize(questionText, displayText);
            
            answerReading.textContent = word.reading || '';
            answerReading.style.display = word.reading ? 'block' : 'none';
            answerMeaning.textContent = state.reverseMode ? word.word : word.meaning;
            
            if (state.testPhase !== 'finished') reportBtns.style.display = 'grid';
            if (ttsState.autoRead && state.currentWord) setTimeout(() => speak(displayText, ttsQuestionBtn), 100);
        }

        function displayFinishedScreen() {
            state.answerVisible = false;
            prevAnswerBar.classList.remove('visible');
            wordChips.classList.add('hidden');
            questionText.textContent = 'ü•≥ Complete!';
            adjustFontSize(questionText, 'Complete');
            answerSection.classList.remove('hidden');
            answerReading.textContent = 'Great job!';
            answerMeaning.textContent = 'All correct!';
            reportBtns.style.display = 'none';
        }

        reportBtns.addEventListener('click', e => {
            const btn = e.target.closest('button');
            if (!btn || !state.currentWord) return;
            const res = btn.dataset.result;
            state.wordStatuses[state.currentWord.id] = res;
            state.previousWord = state.currentWord;
            wordCard.classList.remove('correct-flash', 'review-flash', 'incorrect-flash');
            void wordCard.offsetWidth;
            wordCard.classList.add(`${res}-flash`);
            rebuildUnevaluatedList();
            nextWord();
        });

        prevWordBtn.addEventListener('click', previousWord);
        nextWordBtn.addEventListener('click', nextWord);

        // Edit
        editWordBtn.addEventListener('click', () => {
            if (!state.currentWord) return;
            state.editingFromList = null;
            editWordInput.value = state.currentWord.word;
            editReadingInput.value = state.currentWord.reading || '';
            editMeaningInput.value = state.currentWord.meaning;
            editModalOverlay.classList.add('active');
            editModal.classList.add('active');
        });

        editCancelBtn.addEventListener('click', () => {
            editModalOverlay.classList.remove('active');
            editModal.classList.remove('active');
        });

        editSaveBtn.addEventListener('click', () => {
            const nw = editWordInput.value.trim();
            const nr = editReadingInput.value.trim();
            const nm = editMeaningInput.value.trim();
            
            if (!nw || !nm) { showModal('Error', 'Required fields.'); return; }
            
            const target = state.editingFromList || state.currentWord;
            const oldId = target.id;
            const newId = createWordId(nw, nr);
            
            if (newId !== oldId && state.wordMap.has(newId)) { showModal('Error', 'Exists.'); return; }
            
            const idx = state.allWords.findIndex(w => w.id === oldId);
            if (idx !== -1) {
                if (newId !== oldId) {
                    if (state.wordStatuses[oldId]) { state.wordStatuses[newId] = state.wordStatuses[oldId]; delete state.wordStatuses[oldId]; }
                    if (state.wordDisplayCounts[oldId]) { state.wordDisplayCounts[newId] = state.wordDisplayCounts[oldId]; delete state.wordDisplayCounts[oldId]; }
                    state.wordMap.delete(oldId);
                    const ui = state.unevaluatedWordIds.indexOf(oldId);
                    if (ui !== -1) state.unevaluatedWordIds[ui] = newId;
                }
                
                const updated = { id: newId, word: nw, reading: nr, meaning: nm, initialOrder: state.allWords[idx].initialOrder };
                state.allWords[idx] = updated;
                state.wordMap.set(newId, updated);
                
                if (state.currentWord && state.currentWord.id === oldId) state.currentWord = updated;
                if (newId !== oldId) state.wordHistory = state.wordHistory.map(id => id === oldId ? newId : id);
                
                saveAllWords(state.allWords);
                saveTestState();
                
                if (state.currentWord) displayWord(state.currentWord);
                
                editModalOverlay.classList.remove('active');
                editModal.classList.remove('active');
                showModal('Success', 'Updated.');
            }
        });

        // Settings Buttons
        [probCorrectInput, probReviewInput, probIncorrectInput].forEach(i => i.addEventListener('input', updateProbabilityTotal));

        function updateProbabilityTotal() {
            const tot = (parseInt(probCorrectInput.value)||0) + (parseInt(probReviewInput.value)||0) + (parseInt(probIncorrectInput.value)||0);
            probTotal.textContent = `Total: ${tot}%`;
            probTotal.className = `prob-total ${tot===100?'prob-total-valid':'prob-total-invalid'}`;
            settingsSaveBtn.disabled = tot !== 100;
        }

        settingsSaveBtn.addEventListener('click', () => {
            state.probabilities = {
                correct: parseInt(probCorrectInput.value)/100,
                review: parseInt(probReviewInput.value)/100,
                incorrect: parseInt(probIncorrectInput.value)/100
            };
            saveTestState();
            showModal('Saved', 'Settings updated.');
            closeSettingsFn(); // Use Unified Close
        });

        resetDataBtn.addEventListener('click', () => showConfirmModal('‚ö†Ô∏è Warning', 'Delete all data?', resetAppData));
        
        gotoRegisterBtn.addEventListener('click', () => {
            closeSettingsFn();
            setView('setup');
        });

        reverseModeToggle.addEventListener('change', e => {
            state.reverseMode = e.target.checked;
            saveTestState();
            if(state.currentWord) displayWord(state.currentWord);
        });

        // UI Updates
        function updateResumeButton(hasData) {
            if (hasData && state.allWords.length > 0) {
                resumeTestBtn.disabled = false;
                lastUpdatedTime.textContent = new Date(state.lastUpdated).toLocaleString();
                resumeInfo.textContent = `${state.allWords.length} words`;
                resumeTestBtn.onclick = startTest;
            } else {
                resumeTestBtn.disabled = true;
                lastUpdatedTime.textContent = '--';
                resumeTestBtn.onclick = null;
            }
        }

        function updateStatsDisplay() {
            const counts = { unevaluated: 0, correct: 0, review: 0, incorrect: 0 };
            state.allWords.forEach(w => {
                const status = state.wordStatuses[w.id] || 'unevaluated';
                if (counts[status] !== undefined) counts[status]++;
            });
            
            unevaluatedCount.textContent = counts.unevaluated;
            correctCount.textContent = counts.correct;
            reviewCount.textContent = counts.review;
            incorrectCount.textContent = counts.incorrect;
            
            const total = state.allWords.length;
            const evalCount = total - counts.unevaluated;
            
            unevaluatedProgressBar.style.width = total ? `${(evalCount / total) * 100}%` : '0%';
            unevaluatedProgressText.textContent = `${evalCount} / ${total}`;
            unevaluatedProgress.style.display = counts.unevaluated > 0 ? 'block' : 'none';
            
            const weighted = counts.correct + counts.review * 0.5;
            overallProgressBar.style.width = total ? `${(weighted / total) * 100}%` : '0%';
            overallProgressText.textContent = `${weighted.toFixed(1)} / ${total}`;
        }

        // TTS
        function initTTS() {
            const saved = JSON.parse(localStorage.getItem(LS_TTS_KEY) || '{}');
            ttsState.autoRead = saved.autoRead || false;
            ttsAutoToggle.checked = ttsState.autoRead;
            if ('speechSynthesis' in window) {
                speechSynthesis.onvoiceschanged = () => ttsState.voices = speechSynthesis.getVoices();
                ttsState.voices = speechSynthesis.getVoices();
            }
        }

        function saveTTSState() {
            localStorage.setItem(LS_TTS_KEY, JSON.stringify({ autoRead: ttsState.autoRead }));
        }

        function speak(text, btn) {
            if (!('speechSynthesis' in window)) return;
            speechSynthesis.cancel();
            const ut = new SpeechSynthesisUtterance(text);
            
            // --- UPDATED LANGUAGE DETECTION ---
            if (/[\uAC00-\uD7AF]/.test(text)) ut.lang = 'ko-KR';
            else if (/[\u3040-\u309F\u30A0-\u30FF]/.test(text)) ut.lang = 'ja-JP';
            else if (/[\u4E00-\u9FFF]/.test(text)) ut.lang = 'ja-JP'; 
            else ut.lang = 'en-US';
            
            if (btn) btn.classList.add('speaking');
            ut.onend = ut.onerror = () => btn && btn.classList.remove('speaking');
            speechSynthesis.speak(ut);
        }

        ttsQuestionBtn.addEventListener('click', e => {
            e.stopPropagation();
            if (state.currentWord) speak(state.reverseMode ? state.currentWord.meaning : state.currentWord.word, ttsQuestionBtn);
        });

        ttsAnswerBtn.addEventListener('click', e => {
            e.stopPropagation();
            if (state.currentWord) speak(state.reverseMode ? state.currentWord.word : state.currentWord.meaning, ttsAnswerBtn);
        });

        ttsAutoToggle.addEventListener('change', () => {
            ttsState.autoRead = ttsAutoToggle.checked;
            saveTTSState();
        });

        // Import/Export
        function formatDate() {
            const d = new Date();
            return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
        }

        function downloadBlob(blob, name) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        exportJsonBtn.addEventListener('click', () => {
            const blob = new Blob([JSON.stringify({
                version: 1,
                exportDate: new Date().toISOString(),
                words: state.allWords,
                statuses: state.wordStatuses,
                displayCounts: state.wordDisplayCounts
            }, null, 2)], { type: 'application/json' });
            downloadBlob(blob, `tango_backup_${formatDate()}.json`);
        });

        exportCsvBtn.addEventListener('click', () => {
            let csv = 'word,reading,meaning,status,count\n' + state.allWords.map(w => `"${w.word.replace(/"/g,'""')}","${(w.reading||'').replace(/"/g,'""')}","${w.meaning.replace(/"/g,'""')}","${state.wordStatuses[w.id]||'unevaluated'}",${state.wordDisplayCounts[w.id]||0}`).join('\n');
            downloadBlob(new Blob([csv], { type: 'text/csv;charset=utf-8;' }), `tango_${formatDate()}.csv`);
        });

        importBtn.addEventListener('click', () => importFileInput.click());
        
        // --- IMPROVED CSV PARSING ---
        function parseCSV(text) {
            const lines = text.split(/\r?\n/);
            const result = [];
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const matches = [];
                let current = '';
                let inQuotes = false;
                
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    if (char === '"') {
                        if (inQuotes && line[j + 1] === '"') {
                            current += '"';
                            j++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        matches.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                matches.push(current);
                
                if (matches.length >= 2) {
                    result.push({
                        word: matches[0].trim(),
                        reading: matches[1].trim(),
                        meaning: matches[2] ? matches[2].trim() : matches[1].trim() // fallback
                    });
                }
            }
            return result;
        }

        importFileInput.addEventListener('change', e => {
            if(e.target.files.length) {
                const r = new FileReader();
                r.onload = evt => { 
                    const c = evt.target.result;
                    if(e.target.files[0].name.endsWith('.json')) {
                        try {
                            const d = JSON.parse(c);
                            let added = 0;
                            d.words.forEach(w => {
                                if(!state.wordMap.has(w.id || createWordId(w.word, w.reading))) {
                                    const nw = { ...w, id: w.id || createWordId(w.word, w.reading), initialOrder: state.allWords.length };
                                    state.allWords.push(nw);
                                    state.wordMap.set(nw.id, nw);
                                    if(d.statuses[nw.id]) state.wordStatuses[nw.id] = d.statuses[nw.id];
                                    added++;
                                }
                            });
                            saveAllWords(state.allWords);
                            saveTestState();
                            rebuildUnevaluatedList();
                            updateResumeButton(true);
                            showModal('Imported', `${added} words.`);
                        } catch(x){ showModal('Error', 'Invalid JSON'); }
                    } else {
                        // Use improved CSV parser
                        const parsed = parseCSV(c);
                        let added = 0;
                        parsed.forEach(p => {
                            const id = createWordId(p.word, p.reading);
                            if(!state.wordMap.has(id)) {
                                const nw = { id, word:p.word, reading:p.reading, meaning:p.meaning, initialOrder: state.allWords.length };
                                state.allWords.push(nw);
                                state.wordMap.set(id,nw);
                                added++;
                            }
                        });
                        saveAllWords(state.allWords);
                        saveTestState();
                        rebuildUnevaluatedList();
                        updateResumeButton(true);
                        showModal('Imported', `${added} words.`);
                    }
                };
                r.readAsText(e.target.files[0]);
                e.target.value = '';
            }
        });

        // Word List Rendering
        function renderWordlist() {
            const filter = document.querySelector('.filter-chip.active').dataset.filter;
            const term = wordlistSearch.value.toLowerCase().trim();
            
            const list = state.allWords.filter(w => {
                const status = state.wordStatuses[w.id] || 'unevaluated';
                const matchesFilter = filter === 'all' || status === filter;
                const matchesSearch = w.word.toLowerCase().includes(term) || w.meaning.toLowerCase().includes(term);
                return matchesFilter && matchesSearch;
            });
            
            wordlistCount.textContent = `${list.length} words`;
            
            if (list.length === 0) {
                wordlistContainer.innerHTML = '<p style="text-align:center;padding:20px;color:var(--text-muted);">No words</p>';
                return;
            }
            
            wordlistContainer.innerHTML = list.map(w => {
                const status = state.wordStatuses[w.id] || 'unevaluated';
                const statusChar = status === 'unevaluated' ? '‚àí' : (status === 'correct' ? '‚óã' : (status === 'review' ? '‚ñ≥' : '‚úï'));
                
                return `<div class="word-item" data-id="${w.id}">
                    <div style="flex:1;min-width:0;">
                        <div class="word-item-word">${escapeHTML(w.word)}</div>
                        <div class="word-item-detail">${escapeHTML(w.meaning)}</div>
                    </div>
                    <div class="status-${status}" style="width:24px;height:24px;border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:0.8rem;">
                        ${statusChar}
                    </div>
                </div>`;
            }).join('');
        }

        wordlistSearch.addEventListener('input', renderWordlist);

        document.querySelectorAll('.filter-chip').forEach(c => c.addEventListener('click', () => {
            document.querySelectorAll('.filter-chip').forEach(b => b.classList.remove('active'));
            c.classList.add('active');
            renderWordlist();
        }));

        wordlistContainer.addEventListener('click', e => {
            const i = e.target.closest('.word-item');
            if(i) {
                const w = state.wordMap.get(i.dataset.id);
                if(w) {
                    closeWordlistFn();
                    editWordInput.value = w.word;
                    editReadingInput.value = w.reading||'';
                    editMeaningInput.value = w.meaning;
                    state.editingFromList = w;
                    editModalOverlay.classList.add('active');
                    editModal.classList.add('active');
                }
            }
        });

        // --- NEW: Improved Modal Drag & Swipe-to-Close Handler ---
        // Prevents swipe-to-close from interfering with scrollable content like word lists
        document.querySelectorAll('.modal-sheet').forEach(modal => {
            let startY = 0;
            let currentY = 0;
            let isDragging = false;
            
            modal.addEventListener('touchstart', e => {
                const content = modal; // Modal itself is the scroll container
                const isScrollable = content.scrollHeight > content.clientHeight;
                const isAtTop = content.scrollTop <= 0;
                
                // Only allow drag if content is not scrollable OR content is at the top
                if (!isScrollable || isAtTop) {
                    startY = e.touches[0].clientY;
                    isDragging = true;
                } else {
                    isDragging = false; // Disable dragging when scrolled down
                }
            }, { passive: true });
            
            modal.addEventListener('touchmove', e => {
                if (!isDragging) return;
                
                currentY = e.touches[0].clientY;
                const diff = currentY - startY;
                
                // Only move if dragging down
                if (diff > 0) {
                    // Double check we are still at top if scrollable
                    if (modal.scrollTop > 0) {
                        isDragging = false;
                        modal.style.transform = '';
                        return;
                    }

                    if (e.cancelable) e.preventDefault(); // Prevent scrolling
                    modal.style.transition = 'none';
                    modal.style.transform = `translateY(${diff}px)`;
                } else {
                    // Dragging up (scrolling logic handles this usually, but reset transform just in case)
                    modal.style.transform = '';
                }
            }, { passive: false });
            
            modal.addEventListener('touchend', e => {
                if (!isDragging) return;
                isDragging = false;
                
                modal.style.transition = '';
                const diff = currentY - startY;
                const overlay = modal.previousElementSibling;
                
                if (diff > 120) { // Threshold to close
                    modal.classList.remove('active');
                    if (overlay) overlay.classList.remove('active');
                    setTimeout(() => { modal.style.transform = ''; }, 300);
                } else {
                    modal.style.transform = '';
                }
            });
        });

        // Initialization
        window.onload = () => {
            initTTS();
            initApp();
        };

        function initApp() {
            const w = loadAllWords();
            const s = loadTestState();
            
            if (w.length) {
                state.allWords = w;
                state.wordMap = new Map(w.map(x => [x.id, x]));
            }
            
            if (s && w.length) {
                Object.assign(state, s);
                rebuildUnevaluatedList();
                updateStatsDisplay();
                updateResumeButton(true);
            } else {
                rebuildUnevaluatedList();
                updateResumeButton(false);
            }
            
            updateProbabilityTotal();
            setView('setup');
        }

        // Prevent double-tap zoom
        let lastTouchEnd = 0;
        document.addEventListener('touchend', e => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) e.preventDefault();
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>
